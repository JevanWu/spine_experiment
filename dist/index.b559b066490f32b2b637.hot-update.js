webpackHotUpdate("index",{

/***/ "./node_modules/pixi-spine/bin/pixi-spine.js":
/*!***************************************************!*\
  !*** ./node_modules/pixi-spine/bin/pixi-spine.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Animation = function () {\n      function Animation(name, timelines, duration) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (timelines == null) throw new Error(\"timelines cannot be null.\");\n        this.name = name;\n        this.timelines = timelines;\n        this.duration = duration;\n      }\n\n      Animation.prototype.apply = function (skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n\n        if (loop && this.duration != 0) {\n          time %= this.duration;\n          if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        var timelines = this.timelines;\n\n        for (var i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n      };\n\n      Animation.binarySearch = function (values, target, step) {\n        if (step === void 0) {\n          step = 1;\n        }\n\n        var low = 0;\n        var high = values.length / step - 2;\n        if (high == 0) return step;\n        var current = high >>> 1;\n\n        while (true) {\n          if (values[(current + 1) * step] <= target) low = current + 1;else high = current;\n          if (low == high) return (low + 1) * step;\n          current = low + high >>> 1;\n        }\n      };\n\n      Animation.linearSearch = function (values, target, step) {\n        for (var i = 0, last = values.length - step; i <= last; i += step) if (values[i] > target) return i;\n\n        return -1;\n      };\n\n      return Animation;\n    }();\n\n    core.Animation = Animation;\n    var MixBlend;\n\n    (function (MixBlend) {\n      MixBlend[MixBlend[\"setup\"] = 0] = \"setup\";\n      MixBlend[MixBlend[\"first\"] = 1] = \"first\";\n      MixBlend[MixBlend[\"replace\"] = 2] = \"replace\";\n      MixBlend[MixBlend[\"add\"] = 3] = \"add\";\n    })(MixBlend = core.MixBlend || (core.MixBlend = {}));\n\n    var MixDirection;\n\n    (function (MixDirection) {\n      MixDirection[MixDirection[\"in\"] = 0] = \"in\";\n      MixDirection[MixDirection[\"out\"] = 1] = \"out\";\n    })(MixDirection = core.MixDirection || (core.MixDirection = {}));\n\n    var TimelineType;\n\n    (function (TimelineType) {\n      TimelineType[TimelineType[\"rotate\"] = 0] = \"rotate\";\n      TimelineType[TimelineType[\"translate\"] = 1] = \"translate\";\n      TimelineType[TimelineType[\"scale\"] = 2] = \"scale\";\n      TimelineType[TimelineType[\"shear\"] = 3] = \"shear\";\n      TimelineType[TimelineType[\"attachment\"] = 4] = \"attachment\";\n      TimelineType[TimelineType[\"color\"] = 5] = \"color\";\n      TimelineType[TimelineType[\"deform\"] = 6] = \"deform\";\n      TimelineType[TimelineType[\"event\"] = 7] = \"event\";\n      TimelineType[TimelineType[\"drawOrder\"] = 8] = \"drawOrder\";\n      TimelineType[TimelineType[\"ikConstraint\"] = 9] = \"ikConstraint\";\n      TimelineType[TimelineType[\"transformConstraint\"] = 10] = \"transformConstraint\";\n      TimelineType[TimelineType[\"pathConstraintPosition\"] = 11] = \"pathConstraintPosition\";\n      TimelineType[TimelineType[\"pathConstraintSpacing\"] = 12] = \"pathConstraintSpacing\";\n      TimelineType[TimelineType[\"pathConstraintMix\"] = 13] = \"pathConstraintMix\";\n      TimelineType[TimelineType[\"twoColor\"] = 14] = \"twoColor\";\n    })(TimelineType = core.TimelineType || (core.TimelineType = {}));\n\n    var CurveTimeline = function () {\n      function CurveTimeline(frameCount) {\n        if (frameCount <= 0) throw new Error(\"frameCount must be > 0: \" + frameCount);\n        this.curves = core.Utils.newFloatArray((frameCount - 1) * CurveTimeline.BEZIER_SIZE);\n      }\n\n      CurveTimeline.prototype.getFrameCount = function () {\n        return this.curves.length / CurveTimeline.BEZIER_SIZE + 1;\n      };\n\n      CurveTimeline.prototype.setLinear = function (frameIndex) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.LINEAR;\n      };\n\n      CurveTimeline.prototype.setStepped = function (frameIndex) {\n        this.curves[frameIndex * CurveTimeline.BEZIER_SIZE] = CurveTimeline.STEPPED;\n      };\n\n      CurveTimeline.prototype.getCurveType = function (frameIndex) {\n        var index = frameIndex * CurveTimeline.BEZIER_SIZE;\n        if (index == this.curves.length) return CurveTimeline.LINEAR;\n        var type = this.curves[index];\n        if (type == CurveTimeline.LINEAR) return CurveTimeline.LINEAR;\n        if (type == CurveTimeline.STEPPED) return CurveTimeline.STEPPED;\n        return CurveTimeline.BEZIER;\n      };\n\n      CurveTimeline.prototype.setCurve = function (frameIndex, cx1, cy1, cx2, cy2) {\n        var tmpx = (-cx1 * 2 + cx2) * 0.03,\n            tmpy = (-cy1 * 2 + cy2) * 0.03;\n        var dddfx = ((cx1 - cx2) * 3 + 1) * 0.006,\n            dddfy = ((cy1 - cy2) * 3 + 1) * 0.006;\n        var ddfx = tmpx * 2 + dddfx,\n            ddfy = tmpy * 2 + dddfy;\n        var dfx = cx1 * 0.3 + tmpx + dddfx * 0.16666667,\n            dfy = cy1 * 0.3 + tmpy + dddfy * 0.16666667;\n        var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        var curves = this.curves;\n        curves[i++] = CurveTimeline.BEZIER;\n        var x = dfx,\n            y = dfy;\n\n        for (var n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n          curves[i] = x;\n          curves[i + 1] = y;\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          x += dfx;\n          y += dfy;\n        }\n      };\n\n      CurveTimeline.prototype.getCurvePercent = function (frameIndex, percent) {\n        percent = core.MathUtils.clamp(percent, 0, 1);\n        var curves = this.curves;\n        var i = frameIndex * CurveTimeline.BEZIER_SIZE;\n        var type = curves[i];\n        if (type == CurveTimeline.LINEAR) return percent;\n        if (type == CurveTimeline.STEPPED) return 0;\n        i++;\n        var x = 0;\n\n        for (var start = i, n = i + CurveTimeline.BEZIER_SIZE - 1; i < n; i += 2) {\n          x = curves[i];\n\n          if (x >= percent) {\n            var prevX = void 0,\n                prevY = void 0;\n\n            if (i == start) {\n              prevX = 0;\n              prevY = 0;\n            } else {\n              prevX = curves[i - 2];\n              prevY = curves[i - 1];\n            }\n\n            return prevY + (curves[i + 1] - prevY) * (percent - prevX) / (x - prevX);\n          }\n        }\n\n        var y = curves[i - 1];\n        return y + (1 - y) * (percent - x) / (1 - x);\n      };\n\n      CurveTimeline.LINEAR = 0;\n      CurveTimeline.STEPPED = 1;\n      CurveTimeline.BEZIER = 2;\n      CurveTimeline.BEZIER_SIZE = 10 * 2 - 1;\n      return CurveTimeline;\n    }();\n\n    core.CurveTimeline = CurveTimeline;\n\n    var RotateTimeline = function (_super) {\n      __extends(RotateTimeline, _super);\n\n      function RotateTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount << 1);\n        return _this;\n      }\n\n      RotateTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.rotate << 24) + this.boneIndex;\n      };\n\n      RotateTimeline.prototype.setFrame = function (frameIndex, time, degrees) {\n        frameIndex <<= 1;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + RotateTimeline.ROTATION] = degrees;\n      };\n\n      RotateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var frames = this.frames;\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              bone.rotation = bone.data.rotation;\n              return;\n\n            case MixBlend.first:\n              var r_1 = bone.data.rotation - bone.rotation;\n              bone.rotation += (r_1 - (16384 - (16384.499999999996 - r_1 / 360 | 0)) * 360) * alpha;\n          }\n\n          return;\n        }\n\n        if (time >= frames[frames.length - RotateTimeline.ENTRIES]) {\n          var r_2 = frames[frames.length + RotateTimeline.PREV_ROTATION];\n\n          switch (blend) {\n            case MixBlend.setup:\n              bone.rotation = bone.data.rotation + r_2 * alpha;\n              break;\n\n            case MixBlend.first:\n            case MixBlend.replace:\n              r_2 += bone.data.rotation - bone.rotation;\n              r_2 -= (16384 - (16384.499999999996 - r_2 / 360 | 0)) * 360;\n\n            case MixBlend.add:\n              bone.rotation += r_2 * alpha;\n          }\n\n          return;\n        }\n\n        var frame = Animation.binarySearch(frames, time, RotateTimeline.ENTRIES);\n        var prevRotation = frames[frame + RotateTimeline.PREV_ROTATION];\n        var frameTime = frames[frame];\n        var percent = this.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + RotateTimeline.PREV_TIME] - frameTime));\n        var r = frames[frame + RotateTimeline.ROTATION] - prevRotation;\n        r = prevRotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * percent;\n\n        switch (blend) {\n          case MixBlend.setup:\n            bone.rotation = bone.data.rotation + (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            r += bone.data.rotation - bone.rotation;\n\n          case MixBlend.add:\n            bone.rotation += (r - (16384 - (16384.499999999996 - r / 360 | 0)) * 360) * alpha;\n        }\n      };\n\n      RotateTimeline.ENTRIES = 2;\n      RotateTimeline.PREV_TIME = -2;\n      RotateTimeline.PREV_ROTATION = -1;\n      RotateTimeline.ROTATION = 1;\n      return RotateTimeline;\n    }(CurveTimeline);\n\n    core.RotateTimeline = RotateTimeline;\n\n    var TranslateTimeline = function (_super) {\n      __extends(TranslateTimeline, _super);\n\n      function TranslateTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * TranslateTimeline.ENTRIES);\n        return _this;\n      }\n\n      TranslateTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.translate << 24) + this.boneIndex;\n      };\n\n      TranslateTimeline.prototype.setFrame = function (frameIndex, time, x, y) {\n        frameIndex *= TranslateTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TranslateTimeline.X] = x;\n        this.frames[frameIndex + TranslateTimeline.Y] = y;\n      };\n\n      TranslateTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var frames = this.frames;\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              bone.x = bone.data.x;\n              bone.y = bone.data.y;\n              return;\n\n            case MixBlend.first:\n              bone.x += (bone.data.x - bone.x) * alpha;\n              bone.y += (bone.data.y - bone.y) * alpha;\n          }\n\n          return;\n        }\n\n        var x = 0,\n            y = 0;\n\n        if (time >= frames[frames.length - TranslateTimeline.ENTRIES]) {\n          x = frames[frames.length + TranslateTimeline.PREV_X];\n          y = frames[frames.length + TranslateTimeline.PREV_Y];\n        } else {\n          var frame = Animation.binarySearch(frames, time, TranslateTimeline.ENTRIES);\n          x = frames[frame + TranslateTimeline.PREV_X];\n          y = frames[frame + TranslateTimeline.PREV_Y];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / TranslateTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TranslateTimeline.PREV_TIME] - frameTime));\n          x += (frames[frame + TranslateTimeline.X] - x) * percent;\n          y += (frames[frame + TranslateTimeline.Y] - y) * percent;\n        }\n\n        switch (blend) {\n          case MixBlend.setup:\n            bone.x = bone.data.x + x * alpha;\n            bone.y = bone.data.y + y * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bone.x += (bone.data.x + x - bone.x) * alpha;\n            bone.y += (bone.data.y + y - bone.y) * alpha;\n            break;\n\n          case MixBlend.add:\n            bone.x += x * alpha;\n            bone.y += y * alpha;\n        }\n      };\n\n      TranslateTimeline.ENTRIES = 3;\n      TranslateTimeline.PREV_TIME = -3;\n      TranslateTimeline.PREV_X = -2;\n      TranslateTimeline.PREV_Y = -1;\n      TranslateTimeline.X = 1;\n      TranslateTimeline.Y = 2;\n      return TranslateTimeline;\n    }(CurveTimeline);\n\n    core.TranslateTimeline = TranslateTimeline;\n\n    var ScaleTimeline = function (_super) {\n      __extends(ScaleTimeline, _super);\n\n      function ScaleTimeline(frameCount) {\n        return _super.call(this, frameCount) || this;\n      }\n\n      ScaleTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.scale << 24) + this.boneIndex;\n      };\n\n      ScaleTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var frames = this.frames;\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              bone.scaleX = bone.data.scaleX;\n              bone.scaleY = bone.data.scaleY;\n              return;\n\n            case MixBlend.first:\n              bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n              bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n          }\n\n          return;\n        }\n\n        var x = 0,\n            y = 0;\n\n        if (time >= frames[frames.length - ScaleTimeline.ENTRIES]) {\n          x = frames[frames.length + ScaleTimeline.PREV_X] * bone.data.scaleX;\n          y = frames[frames.length + ScaleTimeline.PREV_Y] * bone.data.scaleY;\n        } else {\n          var frame = Animation.binarySearch(frames, time, ScaleTimeline.ENTRIES);\n          x = frames[frame + ScaleTimeline.PREV_X];\n          y = frames[frame + ScaleTimeline.PREV_Y];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / ScaleTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ScaleTimeline.PREV_TIME] - frameTime));\n          x = (x + (frames[frame + ScaleTimeline.X] - x) * percent) * bone.data.scaleX;\n          y = (y + (frames[frame + ScaleTimeline.Y] - y) * percent) * bone.data.scaleY;\n        }\n\n        if (alpha == 1) {\n          if (blend == MixBlend.add) {\n            bone.scaleX += x - bone.data.scaleX;\n            bone.scaleY += y - bone.data.scaleY;\n          } else {\n            bone.scaleX = x;\n            bone.scaleY = y;\n          }\n        } else {\n          var bx = 0,\n              by = 0;\n\n          if (direction == MixDirection.out) {\n            switch (blend) {\n              case MixBlend.setup:\n                bx = bone.data.scaleX;\n                by = bone.data.scaleY;\n                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\n                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\n                break;\n\n              case MixBlend.first:\n              case MixBlend.replace:\n                bx = bone.scaleX;\n                by = bone.scaleY;\n                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bx) * alpha;\n                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - by) * alpha;\n                break;\n\n              case MixBlend.add:\n                bx = bone.scaleX;\n                by = bone.scaleY;\n                bone.scaleX = bx + (Math.abs(x) * core.MathUtils.signum(bx) - bone.data.scaleX) * alpha;\n                bone.scaleY = by + (Math.abs(y) * core.MathUtils.signum(by) - bone.data.scaleY) * alpha;\n            }\n          } else {\n            switch (blend) {\n              case MixBlend.setup:\n                bx = Math.abs(bone.data.scaleX) * core.MathUtils.signum(x);\n                by = Math.abs(bone.data.scaleY) * core.MathUtils.signum(y);\n                bone.scaleX = bx + (x - bx) * alpha;\n                bone.scaleY = by + (y - by) * alpha;\n                break;\n\n              case MixBlend.first:\n              case MixBlend.replace:\n                bx = Math.abs(bone.scaleX) * core.MathUtils.signum(x);\n                by = Math.abs(bone.scaleY) * core.MathUtils.signum(y);\n                bone.scaleX = bx + (x - bx) * alpha;\n                bone.scaleY = by + (y - by) * alpha;\n                break;\n\n              case MixBlend.add:\n                bx = core.MathUtils.signum(x);\n                by = core.MathUtils.signum(y);\n                bone.scaleX = Math.abs(bone.scaleX) * bx + (x - Math.abs(bone.data.scaleX) * bx) * alpha;\n                bone.scaleY = Math.abs(bone.scaleY) * by + (y - Math.abs(bone.data.scaleY) * by) * alpha;\n            }\n          }\n        }\n      };\n\n      return ScaleTimeline;\n    }(TranslateTimeline);\n\n    core.ScaleTimeline = ScaleTimeline;\n\n    var ShearTimeline = function (_super) {\n      __extends(ShearTimeline, _super);\n\n      function ShearTimeline(frameCount) {\n        return _super.call(this, frameCount) || this;\n      }\n\n      ShearTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.shear << 24) + this.boneIndex;\n      };\n\n      ShearTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var frames = this.frames;\n        var bone = skeleton.bones[this.boneIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              bone.shearX = bone.data.shearX;\n              bone.shearY = bone.data.shearY;\n              return;\n\n            case MixBlend.first:\n              bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n              bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n          }\n\n          return;\n        }\n\n        var x = 0,\n            y = 0;\n\n        if (time >= frames[frames.length - ShearTimeline.ENTRIES]) {\n          x = frames[frames.length + ShearTimeline.PREV_X];\n          y = frames[frames.length + ShearTimeline.PREV_Y];\n        } else {\n          var frame = Animation.binarySearch(frames, time, ShearTimeline.ENTRIES);\n          x = frames[frame + ShearTimeline.PREV_X];\n          y = frames[frame + ShearTimeline.PREV_Y];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / ShearTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ShearTimeline.PREV_TIME] - frameTime));\n          x = x + (frames[frame + ShearTimeline.X] - x) * percent;\n          y = y + (frames[frame + ShearTimeline.Y] - y) * percent;\n        }\n\n        switch (blend) {\n          case MixBlend.setup:\n            bone.shearX = bone.data.shearX + x * alpha;\n            bone.shearY = bone.data.shearY + y * alpha;\n            break;\n\n          case MixBlend.first:\n          case MixBlend.replace:\n            bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n            bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n            break;\n\n          case MixBlend.add:\n            bone.shearX += x * alpha;\n            bone.shearY += y * alpha;\n        }\n      };\n\n      return ShearTimeline;\n    }(TranslateTimeline);\n\n    core.ShearTimeline = ShearTimeline;\n\n    var ColorTimeline = function (_super) {\n      __extends(ColorTimeline, _super);\n\n      function ColorTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * ColorTimeline.ENTRIES);\n        return _this;\n      }\n\n      ColorTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.color << 24) + this.slotIndex;\n      };\n\n      ColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a) {\n        frameIndex *= ColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + ColorTimeline.R] = r;\n        this.frames[frameIndex + ColorTimeline.G] = g;\n        this.frames[frameIndex + ColorTimeline.B] = b;\n        this.frames[frameIndex + ColorTimeline.A] = a;\n      };\n\n      ColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var slot = skeleton.slots[this.slotIndex];\n        var frames = this.frames;\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              slot.color.setFromColor(slot.data.color);\n              return;\n\n            case MixBlend.first:\n              var color = slot.color,\n                  setup = slot.data.color;\n              color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n          }\n\n          return;\n        }\n\n        var r = 0,\n            g = 0,\n            b = 0,\n            a = 0;\n\n        if (time >= frames[frames.length - ColorTimeline.ENTRIES]) {\n          var i = frames.length;\n          r = frames[i + ColorTimeline.PREV_R];\n          g = frames[i + ColorTimeline.PREV_G];\n          b = frames[i + ColorTimeline.PREV_B];\n          a = frames[i + ColorTimeline.PREV_A];\n        } else {\n          var frame = Animation.binarySearch(frames, time, ColorTimeline.ENTRIES);\n          r = frames[frame + ColorTimeline.PREV_R];\n          g = frames[frame + ColorTimeline.PREV_G];\n          b = frames[frame + ColorTimeline.PREV_B];\n          a = frames[frame + ColorTimeline.PREV_A];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / ColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + ColorTimeline.PREV_TIME] - frameTime));\n          r += (frames[frame + ColorTimeline.R] - r) * percent;\n          g += (frames[frame + ColorTimeline.G] - g) * percent;\n          b += (frames[frame + ColorTimeline.B] - b) * percent;\n          a += (frames[frame + ColorTimeline.A] - a) * percent;\n        }\n\n        if (alpha == 1) slot.color.set(r, g, b, a);else {\n          var color = slot.color;\n          if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n          color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n      };\n\n      ColorTimeline.ENTRIES = 5;\n      ColorTimeline.PREV_TIME = -5;\n      ColorTimeline.PREV_R = -4;\n      ColorTimeline.PREV_G = -3;\n      ColorTimeline.PREV_B = -2;\n      ColorTimeline.PREV_A = -1;\n      ColorTimeline.R = 1;\n      ColorTimeline.G = 2;\n      ColorTimeline.B = 3;\n      ColorTimeline.A = 4;\n      return ColorTimeline;\n    }(CurveTimeline);\n\n    core.ColorTimeline = ColorTimeline;\n\n    var TwoColorTimeline = function (_super) {\n      __extends(TwoColorTimeline, _super);\n\n      function TwoColorTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * TwoColorTimeline.ENTRIES);\n        return _this;\n      }\n\n      TwoColorTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.twoColor << 24) + this.slotIndex;\n      };\n\n      TwoColorTimeline.prototype.setFrame = function (frameIndex, time, r, g, b, a, r2, g2, b2) {\n        frameIndex *= TwoColorTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TwoColorTimeline.R] = r;\n        this.frames[frameIndex + TwoColorTimeline.G] = g;\n        this.frames[frameIndex + TwoColorTimeline.B] = b;\n        this.frames[frameIndex + TwoColorTimeline.A] = a;\n        this.frames[frameIndex + TwoColorTimeline.R2] = r2;\n        this.frames[frameIndex + TwoColorTimeline.G2] = g2;\n        this.frames[frameIndex + TwoColorTimeline.B2] = b2;\n      };\n\n      TwoColorTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var slot = skeleton.slots[this.slotIndex];\n        var frames = this.frames;\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              slot.color.setFromColor(slot.data.color);\n              slot.darkColor.setFromColor(slot.data.darkColor);\n              return;\n\n            case MixBlend.first:\n              var light = slot.color,\n                  dark = slot.darkColor,\n                  setupLight = slot.data.color,\n                  setupDark = slot.data.darkColor;\n              light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n              dark.add((setupDark.r - dark.r) * alpha, (setupDark.g - dark.g) * alpha, (setupDark.b - dark.b) * alpha, 0);\n          }\n\n          return;\n        }\n\n        var r = 0,\n            g = 0,\n            b = 0,\n            a = 0,\n            r2 = 0,\n            g2 = 0,\n            b2 = 0;\n\n        if (time >= frames[frames.length - TwoColorTimeline.ENTRIES]) {\n          var i = frames.length;\n          r = frames[i + TwoColorTimeline.PREV_R];\n          g = frames[i + TwoColorTimeline.PREV_G];\n          b = frames[i + TwoColorTimeline.PREV_B];\n          a = frames[i + TwoColorTimeline.PREV_A];\n          r2 = frames[i + TwoColorTimeline.PREV_R2];\n          g2 = frames[i + TwoColorTimeline.PREV_G2];\n          b2 = frames[i + TwoColorTimeline.PREV_B2];\n        } else {\n          var frame = Animation.binarySearch(frames, time, TwoColorTimeline.ENTRIES);\n          r = frames[frame + TwoColorTimeline.PREV_R];\n          g = frames[frame + TwoColorTimeline.PREV_G];\n          b = frames[frame + TwoColorTimeline.PREV_B];\n          a = frames[frame + TwoColorTimeline.PREV_A];\n          r2 = frames[frame + TwoColorTimeline.PREV_R2];\n          g2 = frames[frame + TwoColorTimeline.PREV_G2];\n          b2 = frames[frame + TwoColorTimeline.PREV_B2];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / TwoColorTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TwoColorTimeline.PREV_TIME] - frameTime));\n          r += (frames[frame + TwoColorTimeline.R] - r) * percent;\n          g += (frames[frame + TwoColorTimeline.G] - g) * percent;\n          b += (frames[frame + TwoColorTimeline.B] - b) * percent;\n          a += (frames[frame + TwoColorTimeline.A] - a) * percent;\n          r2 += (frames[frame + TwoColorTimeline.R2] - r2) * percent;\n          g2 += (frames[frame + TwoColorTimeline.G2] - g2) * percent;\n          b2 += (frames[frame + TwoColorTimeline.B2] - b2) * percent;\n        }\n\n        if (alpha == 1) {\n          slot.color.set(r, g, b, a);\n          slot.darkColor.set(r2, g2, b2, 1);\n        } else {\n          var light = slot.color,\n              dark = slot.darkColor;\n\n          if (blend == MixBlend.setup) {\n            light.setFromColor(slot.data.color);\n            dark.setFromColor(slot.data.darkColor);\n          }\n\n          light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n          dark.add((r2 - dark.r) * alpha, (g2 - dark.g) * alpha, (b2 - dark.b) * alpha, 0);\n        }\n      };\n\n      TwoColorTimeline.ENTRIES = 8;\n      TwoColorTimeline.PREV_TIME = -8;\n      TwoColorTimeline.PREV_R = -7;\n      TwoColorTimeline.PREV_G = -6;\n      TwoColorTimeline.PREV_B = -5;\n      TwoColorTimeline.PREV_A = -4;\n      TwoColorTimeline.PREV_R2 = -3;\n      TwoColorTimeline.PREV_G2 = -2;\n      TwoColorTimeline.PREV_B2 = -1;\n      TwoColorTimeline.R = 1;\n      TwoColorTimeline.G = 2;\n      TwoColorTimeline.B = 3;\n      TwoColorTimeline.A = 4;\n      TwoColorTimeline.R2 = 5;\n      TwoColorTimeline.G2 = 6;\n      TwoColorTimeline.B2 = 7;\n      return TwoColorTimeline;\n    }(CurveTimeline);\n\n    core.TwoColorTimeline = TwoColorTimeline;\n\n    var AttachmentTimeline = function () {\n      function AttachmentTimeline(frameCount) {\n        this.frames = core.Utils.newFloatArray(frameCount);\n        this.attachmentNames = new Array(frameCount);\n      }\n\n      AttachmentTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.attachment << 24) + this.slotIndex;\n      };\n\n      AttachmentTimeline.prototype.getFrameCount = function () {\n        return this.frames.length;\n      };\n\n      AttachmentTimeline.prototype.setFrame = function (frameIndex, time, attachmentName) {\n        this.frames[frameIndex] = time;\n        this.attachmentNames[frameIndex] = attachmentName;\n      };\n\n      AttachmentTimeline.prototype.apply = function (skeleton, lastTime, time, events, alpha, blend, direction) {\n        var slot = skeleton.slots[this.slotIndex];\n\n        if (direction == MixDirection.out && blend == MixBlend.setup) {\n          var attachmentName_1 = slot.data.attachmentName;\n          slot.setAttachment(attachmentName_1 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_1));\n          return;\n        }\n\n        var frames = this.frames;\n\n        if (time < frames[0]) {\n          if (blend == MixBlend.setup || blend == MixBlend.first) {\n            var attachmentName_2 = slot.data.attachmentName;\n            slot.setAttachment(attachmentName_2 == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName_2));\n          }\n\n          return;\n        }\n\n        var frameIndex = 0;\n        if (time >= frames[frames.length - 1]) frameIndex = frames.length - 1;else frameIndex = Animation.binarySearch(frames, time, 1) - 1;\n        var attachmentName = this.attachmentNames[frameIndex];\n        skeleton.slots[this.slotIndex].setAttachment(attachmentName == null ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n      };\n\n      return AttachmentTimeline;\n    }();\n\n    core.AttachmentTimeline = AttachmentTimeline;\n    var zeros = null;\n\n    var DeformTimeline = function (_super) {\n      __extends(DeformTimeline, _super);\n\n      function DeformTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount);\n        _this.frameVertices = new Array(frameCount);\n        if (zeros == null) zeros = core.Utils.newFloatArray(64);\n        return _this;\n      }\n\n      DeformTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.deform << 27) + +this.attachment.id + this.slotIndex;\n      };\n\n      DeformTimeline.prototype.setFrame = function (frameIndex, time, vertices) {\n        this.frames[frameIndex] = time;\n        this.frameVertices[frameIndex] = vertices;\n      };\n\n      DeformTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var slot = skeleton.slots[this.slotIndex];\n        var slotAttachment = slot.getAttachment();\n        if (!(slotAttachment instanceof core.VertexAttachment) || !slotAttachment.applyDeform(this.attachment)) return;\n        var verticesArray = slot.attachmentVertices;\n        if (verticesArray.length == 0) blend = MixBlend.setup;\n        var frameVertices = this.frameVertices;\n        var vertexCount = frameVertices[0].length;\n        var frames = this.frames;\n\n        if (time < frames[0]) {\n          var vertexAttachment = slotAttachment;\n\n          switch (blend) {\n            case MixBlend.setup:\n              verticesArray.length = 0;\n              return;\n\n            case MixBlend.first:\n              if (alpha == 1) {\n                verticesArray.length = 0;\n                break;\n              }\n\n              var vertices_1 = core.Utils.setArraySize(verticesArray, vertexCount);\n\n              if (vertexAttachment.bones == null) {\n                var setupVertices = vertexAttachment.vertices;\n\n                for (var i = 0; i < vertexCount; i++) vertices_1[i] += (setupVertices[i] - vertices_1[i]) * alpha;\n              } else {\n                alpha = 1 - alpha;\n\n                for (var i = 0; i < vertexCount; i++) vertices_1[i] *= alpha;\n              }\n\n          }\n\n          return;\n        }\n\n        var vertices = core.Utils.setArraySize(verticesArray, vertexCount);\n\n        if (time >= frames[frames.length - 1]) {\n          var lastVertices = frameVertices[frames.length - 1];\n\n          if (alpha == 1) {\n            if (blend == MixBlend.add) {\n              var vertexAttachment = slotAttachment;\n\n              if (vertexAttachment.bones == null) {\n                var setupVertices = vertexAttachment.vertices;\n\n                for (var i = 0; i < vertexCount; i++) {\n                  vertices[i] += lastVertices[i] - setupVertices[i];\n                }\n              } else {\n                for (var i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i];\n              }\n            } else {\n              core.Utils.arrayCopy(lastVertices, 0, vertices, 0, vertexCount);\n            }\n          } else {\n            switch (blend) {\n              case MixBlend.setup:\n                {\n                  var vertexAttachment_1 = slotAttachment;\n\n                  if (vertexAttachment_1.bones == null) {\n                    var setupVertices = vertexAttachment_1.vertices;\n\n                    for (var i = 0; i < vertexCount; i++) {\n                      var setup = setupVertices[i];\n                      vertices[i] = setup + (lastVertices[i] - setup) * alpha;\n                    }\n                  } else {\n                    for (var i = 0; i < vertexCount; i++) vertices[i] = lastVertices[i] * alpha;\n                  }\n\n                  break;\n                }\n\n              case MixBlend.first:\n              case MixBlend.replace:\n                for (var i = 0; i < vertexCount; i++) vertices[i] += (lastVertices[i] - vertices[i]) * alpha;\n\n              case MixBlend.add:\n                var vertexAttachment = slotAttachment;\n\n                if (vertexAttachment.bones == null) {\n                  var setupVertices = vertexAttachment.vertices;\n\n                  for (var i = 0; i < vertexCount; i++) {\n                    vertices[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                  }\n                } else {\n                  for (var i = 0; i < vertexCount; i++) vertices[i] += lastVertices[i] * alpha;\n                }\n\n            }\n          }\n\n          return;\n        }\n\n        var frame = Animation.binarySearch(frames, time);\n        var prevVertices = frameVertices[frame - 1];\n        var nextVertices = frameVertices[frame];\n        var frameTime = frames[frame];\n        var percent = this.getCurvePercent(frame - 1, 1 - (time - frameTime) / (frames[frame - 1] - frameTime));\n\n        if (alpha == 1) {\n          if (blend == MixBlend.add) {\n            var vertexAttachment = slotAttachment;\n\n            if (vertexAttachment.bones == null) {\n              var setupVertices = vertexAttachment.vertices;\n\n              for (var i = 0; i < vertexCount; i++) {\n                var prev = prevVertices[i];\n                vertices[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n              }\n            } else {\n              for (var i = 0; i < vertexCount; i++) {\n                var prev = prevVertices[i];\n                vertices[i] += prev + (nextVertices[i] - prev) * percent;\n              }\n            }\n          } else {\n            for (var i = 0; i < vertexCount; i++) {\n              var prev = prevVertices[i];\n              vertices[i] = prev + (nextVertices[i] - prev) * percent;\n            }\n          }\n        } else {\n          switch (blend) {\n            case MixBlend.setup:\n              {\n                var vertexAttachment_2 = slotAttachment;\n\n                if (vertexAttachment_2.bones == null) {\n                  var setupVertices = vertexAttachment_2.vertices;\n\n                  for (var i = 0; i < vertexCount; i++) {\n                    var prev = prevVertices[i],\n                        setup = setupVertices[i];\n                    vertices[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                  }\n                } else {\n                  for (var i = 0; i < vertexCount; i++) {\n                    var prev = prevVertices[i];\n                    vertices[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                  }\n                }\n\n                break;\n              }\n\n            case MixBlend.first:\n            case MixBlend.replace:\n              for (var i = 0; i < vertexCount; i++) {\n                var prev = prevVertices[i];\n                vertices[i] += (prev + (nextVertices[i] - prev) * percent - vertices[i]) * alpha;\n              }\n\n              break;\n\n            case MixBlend.add:\n              var vertexAttachment = slotAttachment;\n\n              if (vertexAttachment.bones == null) {\n                var setupVertices = vertexAttachment.vertices;\n\n                for (var i = 0; i < vertexCount; i++) {\n                  var prev = prevVertices[i];\n                  vertices[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                }\n              } else {\n                for (var i = 0; i < vertexCount; i++) {\n                  var prev = prevVertices[i];\n                  vertices[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                }\n              }\n\n          }\n        }\n      };\n\n      return DeformTimeline;\n    }(CurveTimeline);\n\n    core.DeformTimeline = DeformTimeline;\n\n    var EventTimeline = function () {\n      function EventTimeline(frameCount) {\n        this.frames = core.Utils.newFloatArray(frameCount);\n        this.events = new Array(frameCount);\n      }\n\n      EventTimeline.prototype.getPropertyId = function () {\n        return TimelineType.event << 24;\n      };\n\n      EventTimeline.prototype.getFrameCount = function () {\n        return this.frames.length;\n      };\n\n      EventTimeline.prototype.setFrame = function (frameIndex, event) {\n        this.frames[frameIndex] = event.time;\n        this.events[frameIndex] = event;\n      };\n\n      EventTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        if (firedEvents == null) return;\n        var frames = this.frames;\n        var frameCount = this.frames.length;\n\n        if (lastTime > time) {\n          this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n          lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1]) return;\n\n        if (time < frames[0]) return;\n        var frame = 0;\n        if (lastTime < frames[0]) frame = 0;else {\n          frame = Animation.binarySearch(frames, lastTime);\n          var frameTime = frames[frame];\n\n          while (frame > 0) {\n            if (frames[frame - 1] != frameTime) break;\n            frame--;\n          }\n        }\n\n        for (; frame < frameCount && time >= frames[frame]; frame++) firedEvents.push(this.events[frame]);\n      };\n\n      return EventTimeline;\n    }();\n\n    core.EventTimeline = EventTimeline;\n\n    var DrawOrderTimeline = function () {\n      function DrawOrderTimeline(frameCount) {\n        this.frames = core.Utils.newFloatArray(frameCount);\n        this.drawOrders = new Array(frameCount);\n      }\n\n      DrawOrderTimeline.prototype.getPropertyId = function () {\n        return TimelineType.drawOrder << 24;\n      };\n\n      DrawOrderTimeline.prototype.getFrameCount = function () {\n        return this.frames.length;\n      };\n\n      DrawOrderTimeline.prototype.setFrame = function (frameIndex, time, drawOrder) {\n        this.frames[frameIndex] = time;\n        this.drawOrders[frameIndex] = drawOrder;\n      };\n\n      DrawOrderTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var drawOrder = skeleton.drawOrder;\n        var slots = skeleton.slots;\n\n        if (direction == MixDirection.out && blend == MixBlend.setup) {\n          core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n          return;\n        }\n\n        var frames = this.frames;\n\n        if (time < frames[0]) {\n          if (blend == MixBlend.setup || blend == MixBlend.first) core.Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n          return;\n        }\n\n        var frame = 0;\n        if (time >= frames[frames.length - 1]) frame = frames.length - 1;else frame = Animation.binarySearch(frames, time) - 1;\n        var drawOrderToSetupIndex = this.drawOrders[frame];\n        if (drawOrderToSetupIndex == null) core.Utils.arrayCopy(slots, 0, drawOrder, 0, slots.length);else {\n          for (var i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n      };\n\n      return DrawOrderTimeline;\n    }();\n\n    core.DrawOrderTimeline = DrawOrderTimeline;\n\n    var IkConstraintTimeline = function (_super) {\n      __extends(IkConstraintTimeline, _super);\n\n      function IkConstraintTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * IkConstraintTimeline.ENTRIES);\n        return _this;\n      }\n\n      IkConstraintTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.ikConstraint << 24) + this.ikConstraintIndex;\n      };\n\n      IkConstraintTimeline.prototype.setFrame = function (frameIndex, time, mix, bendDirection, compress, stretch) {\n        frameIndex *= IkConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + IkConstraintTimeline.MIX] = mix;\n        this.frames[frameIndex + IkConstraintTimeline.BEND_DIRECTION] = bendDirection;\n        this.frames[frameIndex + IkConstraintTimeline.COMPRESS] = compress ? 1 : 0;\n        this.frames[frameIndex + IkConstraintTimeline.STRETCH] = stretch ? 1 : 0;\n      };\n\n      IkConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var frames = this.frames;\n        var constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              constraint.mix = constraint.data.mix;\n              constraint.bendDirection = constraint.data.bendDirection;\n              constraint.compress = constraint.data.compress;\n              constraint.stretch = constraint.data.stretch;\n              return;\n\n            case MixBlend.first:\n              constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n              constraint.bendDirection = constraint.data.bendDirection;\n              constraint.compress = constraint.data.compress;\n              constraint.stretch = constraint.data.stretch;\n          }\n\n          return;\n        }\n\n        if (time >= frames[frames.length - IkConstraintTimeline.ENTRIES]) {\n          if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.data.mix) * alpha;\n\n            if (direction == MixDirection.out) {\n              constraint.bendDirection = constraint.data.bendDirection;\n              constraint.compress = constraint.data.compress;\n              constraint.stretch = constraint.data.stretch;\n            } else {\n              constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n              constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n              constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n          } else {\n            constraint.mix += (frames[frames.length + IkConstraintTimeline.PREV_MIX] - constraint.mix) * alpha;\n\n            if (direction == MixDirection.in) {\n              constraint.bendDirection = frames[frames.length + IkConstraintTimeline.PREV_BEND_DIRECTION];\n              constraint.compress = frames[frames.length + IkConstraintTimeline.PREV_COMPRESS] != 0;\n              constraint.stretch = frames[frames.length + IkConstraintTimeline.PREV_STRETCH] != 0;\n            }\n          }\n\n          return;\n        }\n\n        var frame = Animation.binarySearch(frames, time, IkConstraintTimeline.ENTRIES);\n        var mix = frames[frame + IkConstraintTimeline.PREV_MIX];\n        var frameTime = frames[frame];\n        var percent = this.getCurvePercent(frame / IkConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + IkConstraintTimeline.PREV_TIME] - frameTime));\n\n        if (blend == MixBlend.setup) {\n          constraint.mix = constraint.data.mix + (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.data.mix) * alpha;\n\n          if (direction == MixDirection.out) {\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n          } else {\n            constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n            constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n          }\n        } else {\n          constraint.mix += (mix + (frames[frame + IkConstraintTimeline.MIX] - mix) * percent - constraint.mix) * alpha;\n\n          if (direction == MixDirection.in) {\n            constraint.bendDirection = frames[frame + IkConstraintTimeline.PREV_BEND_DIRECTION];\n            constraint.compress = frames[frame + IkConstraintTimeline.PREV_COMPRESS] != 0;\n            constraint.stretch = frames[frame + IkConstraintTimeline.PREV_STRETCH] != 0;\n          }\n        }\n      };\n\n      IkConstraintTimeline.ENTRIES = 5;\n      IkConstraintTimeline.PREV_TIME = -5;\n      IkConstraintTimeline.PREV_MIX = -4;\n      IkConstraintTimeline.PREV_BEND_DIRECTION = -3;\n      IkConstraintTimeline.PREV_COMPRESS = -2;\n      IkConstraintTimeline.PREV_STRETCH = -1;\n      IkConstraintTimeline.MIX = 1;\n      IkConstraintTimeline.BEND_DIRECTION = 2;\n      IkConstraintTimeline.COMPRESS = 3;\n      IkConstraintTimeline.STRETCH = 4;\n      return IkConstraintTimeline;\n    }(CurveTimeline);\n\n    core.IkConstraintTimeline = IkConstraintTimeline;\n\n    var TransformConstraintTimeline = function (_super) {\n      __extends(TransformConstraintTimeline, _super);\n\n      function TransformConstraintTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * TransformConstraintTimeline.ENTRIES);\n        return _this;\n      }\n\n      TransformConstraintTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.transformConstraint << 24) + this.transformConstraintIndex;\n      };\n\n      TransformConstraintTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix, scaleMix, shearMix) {\n        frameIndex *= TransformConstraintTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + TransformConstraintTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.TRANSLATE] = translateMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SCALE] = scaleMix;\n        this.frames[frameIndex + TransformConstraintTimeline.SHEAR] = shearMix;\n      };\n\n      TransformConstraintTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var frames = this.frames;\n        var constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (time < frames[0]) {\n          var data = constraint.data;\n\n          switch (blend) {\n            case MixBlend.setup:\n              constraint.rotateMix = data.rotateMix;\n              constraint.translateMix = data.translateMix;\n              constraint.scaleMix = data.scaleMix;\n              constraint.shearMix = data.shearMix;\n              return;\n\n            case MixBlend.first:\n              constraint.rotateMix += (data.rotateMix - constraint.rotateMix) * alpha;\n              constraint.translateMix += (data.translateMix - constraint.translateMix) * alpha;\n              constraint.scaleMix += (data.scaleMix - constraint.scaleMix) * alpha;\n              constraint.shearMix += (data.shearMix - constraint.shearMix) * alpha;\n          }\n\n          return;\n        }\n\n        var rotate = 0,\n            translate = 0,\n            scale = 0,\n            shear = 0;\n\n        if (time >= frames[frames.length - TransformConstraintTimeline.ENTRIES]) {\n          var i = frames.length;\n          rotate = frames[i + TransformConstraintTimeline.PREV_ROTATE];\n          translate = frames[i + TransformConstraintTimeline.PREV_TRANSLATE];\n          scale = frames[i + TransformConstraintTimeline.PREV_SCALE];\n          shear = frames[i + TransformConstraintTimeline.PREV_SHEAR];\n        } else {\n          var frame = Animation.binarySearch(frames, time, TransformConstraintTimeline.ENTRIES);\n          rotate = frames[frame + TransformConstraintTimeline.PREV_ROTATE];\n          translate = frames[frame + TransformConstraintTimeline.PREV_TRANSLATE];\n          scale = frames[frame + TransformConstraintTimeline.PREV_SCALE];\n          shear = frames[frame + TransformConstraintTimeline.PREV_SHEAR];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / TransformConstraintTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + TransformConstraintTimeline.PREV_TIME] - frameTime));\n          rotate += (frames[frame + TransformConstraintTimeline.ROTATE] - rotate) * percent;\n          translate += (frames[frame + TransformConstraintTimeline.TRANSLATE] - translate) * percent;\n          scale += (frames[frame + TransformConstraintTimeline.SCALE] - scale) * percent;\n          shear += (frames[frame + TransformConstraintTimeline.SHEAR] - shear) * percent;\n        }\n\n        if (blend == MixBlend.setup) {\n          var data = constraint.data;\n          constraint.rotateMix = data.rotateMix + (rotate - data.rotateMix) * alpha;\n          constraint.translateMix = data.translateMix + (translate - data.translateMix) * alpha;\n          constraint.scaleMix = data.scaleMix + (scale - data.scaleMix) * alpha;\n          constraint.shearMix = data.shearMix + (shear - data.shearMix) * alpha;\n        } else {\n          constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n          constraint.translateMix += (translate - constraint.translateMix) * alpha;\n          constraint.scaleMix += (scale - constraint.scaleMix) * alpha;\n          constraint.shearMix += (shear - constraint.shearMix) * alpha;\n        }\n      };\n\n      TransformConstraintTimeline.ENTRIES = 5;\n      TransformConstraintTimeline.PREV_TIME = -5;\n      TransformConstraintTimeline.PREV_ROTATE = -4;\n      TransformConstraintTimeline.PREV_TRANSLATE = -3;\n      TransformConstraintTimeline.PREV_SCALE = -2;\n      TransformConstraintTimeline.PREV_SHEAR = -1;\n      TransformConstraintTimeline.ROTATE = 1;\n      TransformConstraintTimeline.TRANSLATE = 2;\n      TransformConstraintTimeline.SCALE = 3;\n      TransformConstraintTimeline.SHEAR = 4;\n      return TransformConstraintTimeline;\n    }(CurveTimeline);\n\n    core.TransformConstraintTimeline = TransformConstraintTimeline;\n\n    var PathConstraintPositionTimeline = function (_super) {\n      __extends(PathConstraintPositionTimeline, _super);\n\n      function PathConstraintPositionTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintPositionTimeline.ENTRIES);\n        return _this;\n      }\n\n      PathConstraintPositionTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.pathConstraintPosition << 24) + this.pathConstraintIndex;\n      };\n\n      PathConstraintPositionTimeline.prototype.setFrame = function (frameIndex, time, value) {\n        frameIndex *= PathConstraintPositionTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintPositionTimeline.VALUE] = value;\n      };\n\n      PathConstraintPositionTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var frames = this.frames;\n        var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              constraint.position = constraint.data.position;\n              return;\n\n            case MixBlend.first:\n              constraint.position += (constraint.data.position - constraint.position) * alpha;\n          }\n\n          return;\n        }\n\n        var position = 0;\n        if (time >= frames[frames.length - PathConstraintPositionTimeline.ENTRIES]) position = frames[frames.length + PathConstraintPositionTimeline.PREV_VALUE];else {\n          var frame = Animation.binarySearch(frames, time, PathConstraintPositionTimeline.ENTRIES);\n          position = frames[frame + PathConstraintPositionTimeline.PREV_VALUE];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / PathConstraintPositionTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintPositionTimeline.PREV_TIME] - frameTime));\n          position += (frames[frame + PathConstraintPositionTimeline.VALUE] - position) * percent;\n        }\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;\n      };\n\n      PathConstraintPositionTimeline.ENTRIES = 2;\n      PathConstraintPositionTimeline.PREV_TIME = -2;\n      PathConstraintPositionTimeline.PREV_VALUE = -1;\n      PathConstraintPositionTimeline.VALUE = 1;\n      return PathConstraintPositionTimeline;\n    }(CurveTimeline);\n\n    core.PathConstraintPositionTimeline = PathConstraintPositionTimeline;\n\n    var PathConstraintSpacingTimeline = function (_super) {\n      __extends(PathConstraintSpacingTimeline, _super);\n\n      function PathConstraintSpacingTimeline(frameCount) {\n        return _super.call(this, frameCount) || this;\n      }\n\n      PathConstraintSpacingTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.pathConstraintSpacing << 24) + this.pathConstraintIndex;\n      };\n\n      PathConstraintSpacingTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var frames = this.frames;\n        var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              constraint.spacing = constraint.data.spacing;\n              return;\n\n            case MixBlend.first:\n              constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n          }\n\n          return;\n        }\n\n        var spacing = 0;\n        if (time >= frames[frames.length - PathConstraintSpacingTimeline.ENTRIES]) spacing = frames[frames.length + PathConstraintSpacingTimeline.PREV_VALUE];else {\n          var frame = Animation.binarySearch(frames, time, PathConstraintSpacingTimeline.ENTRIES);\n          spacing = frames[frame + PathConstraintSpacingTimeline.PREV_VALUE];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / PathConstraintSpacingTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintSpacingTimeline.PREV_TIME] - frameTime));\n          spacing += (frames[frame + PathConstraintSpacingTimeline.VALUE] - spacing) * percent;\n        }\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;\n      };\n\n      return PathConstraintSpacingTimeline;\n    }(PathConstraintPositionTimeline);\n\n    core.PathConstraintSpacingTimeline = PathConstraintSpacingTimeline;\n\n    var PathConstraintMixTimeline = function (_super) {\n      __extends(PathConstraintMixTimeline, _super);\n\n      function PathConstraintMixTimeline(frameCount) {\n        var _this = _super.call(this, frameCount) || this;\n\n        _this.frames = core.Utils.newFloatArray(frameCount * PathConstraintMixTimeline.ENTRIES);\n        return _this;\n      }\n\n      PathConstraintMixTimeline.prototype.getPropertyId = function () {\n        return (TimelineType.pathConstraintMix << 24) + this.pathConstraintIndex;\n      };\n\n      PathConstraintMixTimeline.prototype.setFrame = function (frameIndex, time, rotateMix, translateMix) {\n        frameIndex *= PathConstraintMixTimeline.ENTRIES;\n        this.frames[frameIndex] = time;\n        this.frames[frameIndex + PathConstraintMixTimeline.ROTATE] = rotateMix;\n        this.frames[frameIndex + PathConstraintMixTimeline.TRANSLATE] = translateMix;\n      };\n\n      PathConstraintMixTimeline.prototype.apply = function (skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n        var frames = this.frames;\n        var constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case MixBlend.setup:\n              constraint.rotateMix = constraint.data.rotateMix;\n              constraint.translateMix = constraint.data.translateMix;\n              return;\n\n            case MixBlend.first:\n              constraint.rotateMix += (constraint.data.rotateMix - constraint.rotateMix) * alpha;\n              constraint.translateMix += (constraint.data.translateMix - constraint.translateMix) * alpha;\n          }\n\n          return;\n        }\n\n        var rotate = 0,\n            translate = 0;\n\n        if (time >= frames[frames.length - PathConstraintMixTimeline.ENTRIES]) {\n          rotate = frames[frames.length + PathConstraintMixTimeline.PREV_ROTATE];\n          translate = frames[frames.length + PathConstraintMixTimeline.PREV_TRANSLATE];\n        } else {\n          var frame = Animation.binarySearch(frames, time, PathConstraintMixTimeline.ENTRIES);\n          rotate = frames[frame + PathConstraintMixTimeline.PREV_ROTATE];\n          translate = frames[frame + PathConstraintMixTimeline.PREV_TRANSLATE];\n          var frameTime = frames[frame];\n          var percent = this.getCurvePercent(frame / PathConstraintMixTimeline.ENTRIES - 1, 1 - (time - frameTime) / (frames[frame + PathConstraintMixTimeline.PREV_TIME] - frameTime));\n          rotate += (frames[frame + PathConstraintMixTimeline.ROTATE] - rotate) * percent;\n          translate += (frames[frame + PathConstraintMixTimeline.TRANSLATE] - translate) * percent;\n        }\n\n        if (blend == MixBlend.setup) {\n          constraint.rotateMix = constraint.data.rotateMix + (rotate - constraint.data.rotateMix) * alpha;\n          constraint.translateMix = constraint.data.translateMix + (translate - constraint.data.translateMix) * alpha;\n        } else {\n          constraint.rotateMix += (rotate - constraint.rotateMix) * alpha;\n          constraint.translateMix += (translate - constraint.translateMix) * alpha;\n        }\n      };\n\n      PathConstraintMixTimeline.ENTRIES = 3;\n      PathConstraintMixTimeline.PREV_TIME = -3;\n      PathConstraintMixTimeline.PREV_ROTATE = -2;\n      PathConstraintMixTimeline.PREV_TRANSLATE = -1;\n      PathConstraintMixTimeline.ROTATE = 1;\n      PathConstraintMixTimeline.TRANSLATE = 2;\n      return PathConstraintMixTimeline;\n    }(CurveTimeline);\n\n    core.PathConstraintMixTimeline = PathConstraintMixTimeline;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var AnimationState = function () {\n      function AnimationState(data) {\n        this.tracks = new Array();\n        this.events = new Array();\n        this.listeners = new Array();\n        this.queue = new EventQueue(this);\n        this.propertyIDs = new core.IntSet();\n        this.animationsChanged = false;\n        this.timeScale = 1;\n        this.trackEntryPool = new core.Pool(function () {\n          return new TrackEntry();\n        });\n        this.data = data;\n      }\n\n      AnimationState.prototype.update = function (delta) {\n        delta *= this.timeScale;\n        var tracks = this.tracks;\n\n        for (var i = 0, n = tracks.length; i < n; i++) {\n          var current = tracks[i];\n          if (current == null) continue;\n          current.animationLast = current.nextAnimationLast;\n          current.trackLast = current.nextTrackLast;\n          var currentDelta = delta * current.timeScale;\n\n          if (current.delay > 0) {\n            current.delay -= currentDelta;\n            if (current.delay > 0) continue;\n            currentDelta = -current.delay;\n            current.delay = 0;\n          }\n\n          var next = current.next;\n\n          if (next != null) {\n            var nextTime = current.trackLast - next.delay;\n\n            if (nextTime >= 0) {\n              next.delay = 0;\n              next.trackTime = current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n              current.trackTime += currentDelta;\n              this.setCurrent(i, next, true);\n\n              while (next.mixingFrom != null) {\n                next.mixTime += delta;\n                next = next.mixingFrom;\n              }\n\n              continue;\n            }\n          } else if (current.trackLast >= current.trackEnd && current.mixingFrom == null) {\n            tracks[i] = null;\n            this.queue.end(current);\n            this.disposeNext(current);\n            continue;\n          }\n\n          if (current.mixingFrom != null && this.updateMixingFrom(current, delta)) {\n            var from = current.mixingFrom;\n            current.mixingFrom = null;\n            if (from != null) from.mixingTo = null;\n\n            while (from != null) {\n              this.queue.end(from);\n              from = from.mixingFrom;\n            }\n          }\n\n          current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n      };\n\n      AnimationState.prototype.updateMixingFrom = function (to, delta) {\n        var from = to.mixingFrom;\n        if (from == null) return true;\n        var finished = this.updateMixingFrom(from, delta);\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n          if (from.totalAlpha == 0 || to.mixDuration == 0) {\n            to.mixingFrom = from.mixingFrom;\n            if (from.mixingFrom != null) from.mixingFrom.mixingTo = to;\n            to.interruptAlpha = from.interruptAlpha;\n            this.queue.end(from);\n          }\n\n          return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n        return false;\n      };\n\n      AnimationState.prototype.apply = function (skeleton) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        if (this.animationsChanged) this._animationsChanged();\n        var events = this.events;\n        var tracks = this.tracks;\n        var applied = false;\n\n        for (var i = 0, n = tracks.length; i < n; i++) {\n          var current = tracks[i];\n          if (current == null || current.delay > 0) continue;\n          applied = true;\n          var blend = i == 0 ? core.MixBlend.first : current.mixBlend;\n          var mix = current.alpha;\n          if (current.mixingFrom != null) mix *= this.applyMixingFrom(current, skeleton, blend);else if (current.trackTime >= current.trackEnd && current.next == null) mix = 0;\n          var animationLast = current.animationLast,\n              animationTime = current.getAnimationTime();\n          var timelineCount = current.animation.timelines.length;\n          var timelines = current.animation.timelines;\n\n          if (i == 0 && (mix == 1 || blend == core.MixBlend.add)) {\n            for (var ii = 0; ii < timelineCount; ii++) timelines[ii].apply(skeleton, animationLast, animationTime, events, mix, blend, core.MixDirection.in);\n          } else {\n            var timelineMode = current.timelineMode;\n            var firstFrame = current.timelinesRotation.length == 0;\n            if (firstFrame) core.Utils.setArraySize(current.timelinesRotation, timelineCount << 1, null);\n            var timelinesRotation = current.timelinesRotation;\n\n            for (var ii = 0; ii < timelineCount; ii++) {\n              var timeline = timelines[ii];\n              var timelineBlend = timelineMode[ii] == AnimationState.SUBSEQUENT ? blend : core.MixBlend.setup;\n\n              if (timeline instanceof core.RotateTimeline) {\n                this.applyRotateTimeline(timeline, skeleton, animationTime, mix, timelineBlend, timelinesRotation, ii << 1, firstFrame);\n              } else {\n                core.Utils.webkit602BugfixHelper(mix, blend);\n                timeline.apply(skeleton, animationLast, animationTime, events, mix, timelineBlend, core.MixDirection.in);\n              }\n            }\n          }\n\n          this.queueEvents(current, animationTime);\n          events.length = 0;\n          current.nextAnimationLast = animationTime;\n          current.nextTrackLast = current.trackTime;\n        }\n\n        this.queue.drain();\n        return applied;\n      };\n\n      AnimationState.prototype.applyMixingFrom = function (to, skeleton, blend) {\n        var from = to.mixingFrom;\n        if (from.mixingFrom != null) this.applyMixingFrom(from, skeleton, blend);\n        var mix = 0;\n\n        if (to.mixDuration == 0) {\n          mix = 1;\n          if (blend == core.MixBlend.first) blend = core.MixBlend.setup;\n        } else {\n          mix = to.mixTime / to.mixDuration;\n          if (mix > 1) mix = 1;\n          if (blend != core.MixBlend.first) blend = from.mixBlend;\n        }\n\n        var events = mix < from.eventThreshold ? this.events : null;\n        var attachments = mix < from.attachmentThreshold,\n            drawOrder = mix < from.drawOrderThreshold;\n        var animationLast = from.animationLast,\n            animationTime = from.getAnimationTime();\n        var timelineCount = from.animation.timelines.length;\n        var timelines = from.animation.timelines;\n        var alphaHold = from.alpha * to.interruptAlpha,\n            alphaMix = alphaHold * (1 - mix);\n\n        if (blend == core.MixBlend.add) {\n          for (var i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, animationTime, events, alphaMix, blend, core.MixDirection.out);\n        } else {\n          var timelineMode = from.timelineMode;\n          var timelineHoldMix = from.timelineHoldMix;\n          var firstFrame = from.timelinesRotation.length == 0;\n          if (firstFrame) core.Utils.setArraySize(from.timelinesRotation, timelineCount << 1, null);\n          var timelinesRotation = from.timelinesRotation;\n          from.totalAlpha = 0;\n\n          for (var i = 0; i < timelineCount; i++) {\n            var timeline = timelines[i];\n            var direction = core.MixDirection.out;\n            var timelineBlend = void 0;\n            var alpha = 0;\n\n            switch (timelineMode[i]) {\n              case AnimationState.SUBSEQUENT:\n                if (!attachments && timeline instanceof core.AttachmentTimeline) continue;\n                if (!drawOrder && timeline instanceof core.DrawOrderTimeline) continue;\n                timelineBlend = blend;\n                alpha = alphaMix;\n                break;\n\n              case AnimationState.FIRST:\n                timelineBlend = core.MixBlend.setup;\n                alpha = alphaMix;\n                break;\n\n              case AnimationState.HOLD:\n                timelineBlend = core.MixBlend.setup;\n                alpha = alphaHold;\n                break;\n\n              default:\n                timelineBlend = core.MixBlend.setup;\n                var holdMix = timelineHoldMix[i];\n                alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                break;\n            }\n\n            from.totalAlpha += alpha;\n            if (timeline instanceof core.RotateTimeline) this.applyRotateTimeline(timeline, skeleton, animationTime, alpha, timelineBlend, timelinesRotation, i << 1, firstFrame);else {\n              core.Utils.webkit602BugfixHelper(alpha, blend);\n\n              if (timelineBlend == core.MixBlend.setup) {\n                if (timeline instanceof core.AttachmentTimeline) {\n                  if (attachments) direction = core.MixDirection.out;\n                } else if (timeline instanceof core.DrawOrderTimeline) {\n                  if (drawOrder) direction = core.MixDirection.out;\n                }\n              }\n\n              timeline.apply(skeleton, animationLast, animationTime, events, alpha, timelineBlend, direction);\n            }\n          }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n        return mix;\n      };\n\n      AnimationState.prototype.applyRotateTimeline = function (timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n          timeline.apply(skeleton, 0, time, null, 1, blend, core.MixDirection.in);\n          return;\n        }\n\n        var rotateTimeline = timeline;\n        var frames = rotateTimeline.frames;\n        var bone = skeleton.bones[rotateTimeline.boneIndex];\n        var r1 = 0,\n            r2 = 0;\n\n        if (time < frames[0]) {\n          switch (blend) {\n            case core.MixBlend.setup:\n              bone.rotation = bone.data.rotation;\n\n            default:\n              return;\n\n            case core.MixBlend.first:\n              r1 = bone.rotation;\n              r2 = bone.data.rotation;\n          }\n        } else {\n          r1 = blend == core.MixBlend.setup ? bone.data.rotation : bone.rotation;\n          if (time >= frames[frames.length - core.RotateTimeline.ENTRIES]) r2 = bone.data.rotation + frames[frames.length + core.RotateTimeline.PREV_ROTATION];else {\n            var frame = core.Animation.binarySearch(frames, time, core.RotateTimeline.ENTRIES);\n            var prevRotation = frames[frame + core.RotateTimeline.PREV_ROTATION];\n            var frameTime = frames[frame];\n            var percent = rotateTimeline.getCurvePercent((frame >> 1) - 1, 1 - (time - frameTime) / (frames[frame + core.RotateTimeline.PREV_TIME] - frameTime));\n            r2 = frames[frame + core.RotateTimeline.ROTATION] - prevRotation;\n            r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n            r2 = prevRotation + r2 * percent + bone.data.rotation;\n            r2 -= (16384 - (16384.499999999996 - r2 / 360 | 0)) * 360;\n          }\n        }\n\n        var total = 0,\n            diff = r2 - r1;\n        diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n\n        if (diff == 0) {\n          total = timelinesRotation[i];\n        } else {\n          var lastTotal = 0,\n              lastDiff = 0;\n\n          if (firstFrame) {\n            lastTotal = 0;\n            lastDiff = diff;\n          } else {\n            lastTotal = timelinesRotation[i];\n            lastDiff = timelinesRotation[i + 1];\n          }\n\n          var current = diff > 0,\n              dir = lastTotal >= 0;\n\n          if (core.MathUtils.signum(lastDiff) != core.MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n            if (Math.abs(lastTotal) > 180) lastTotal += 360 * core.MathUtils.signum(lastTotal);\n            dir = current;\n          }\n\n          total = diff + lastTotal - lastTotal % 360;\n          if (dir != current) total += 360 * core.MathUtils.signum(lastTotal);\n          timelinesRotation[i] = total;\n        }\n\n        timelinesRotation[i + 1] = diff;\n        r1 += total * alpha;\n        bone.rotation = r1 - (16384 - (16384.499999999996 - r1 / 360 | 0)) * 360;\n      };\n\n      AnimationState.prototype.queueEvents = function (entry, animationTime) {\n        var animationStart = entry.animationStart,\n            animationEnd = entry.animationEnd;\n        var duration = animationEnd - animationStart;\n        var trackLastWrapped = entry.trackLast % duration;\n        var events = this.events;\n        var i = 0,\n            n = events.length;\n\n        for (; i < n; i++) {\n          var event_1 = events[i];\n          if (event_1.time < trackLastWrapped) break;\n          if (event_1.time > animationEnd) continue;\n          this.queue.event(entry, event_1);\n        }\n\n        var complete = false;\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        for (; i < n; i++) {\n          var event_2 = events[i];\n          if (event_2.time < animationStart) continue;\n          this.queue.event(entry, events[i]);\n        }\n      };\n\n      AnimationState.prototype.clearTracks = function () {\n        var oldDrainDisabled = this.queue.drainDisabled;\n        this.queue.drainDisabled = true;\n\n        for (var i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n      };\n\n      AnimationState.prototype.clearTrack = function (trackIndex) {\n        if (trackIndex >= this.tracks.length) return;\n        var current = this.tracks[trackIndex];\n        if (current == null) return;\n        this.queue.end(current);\n        this.disposeNext(current);\n        var entry = current;\n\n        while (true) {\n          var from = entry.mixingFrom;\n          if (from == null) break;\n          this.queue.end(from);\n          entry.mixingFrom = null;\n          entry.mixingTo = null;\n          entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n        this.queue.drain();\n      };\n\n      AnimationState.prototype.setCurrent = function (index, current, interrupt) {\n        var from = this.expandToIndex(index);\n        this.tracks[index] = current;\n\n        if (from != null) {\n          if (interrupt) this.queue.interrupt(from);\n          current.mixingFrom = from;\n          from.mixingTo = current;\n          current.mixTime = 0;\n          if (from.mixingFrom != null && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n          from.timelinesRotation.length = 0;\n        }\n\n        this.queue.start(current);\n      };\n\n      AnimationState.prototype.setAnimation = function (trackIndex, animationName, loop) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.setAnimationWith(trackIndex, animation, loop);\n      };\n\n      AnimationState.prototype.setAnimationWith = function (trackIndex, animation, loop) {\n        if (animation == null) throw new Error(\"animation cannot be null.\");\n        var interrupt = true;\n        var current = this.expandToIndex(trackIndex);\n\n        if (current != null) {\n          if (current.nextTrackLast == -1) {\n            this.tracks[trackIndex] = current.mixingFrom;\n            this.queue.interrupt(current);\n            this.queue.end(current);\n            this.disposeNext(current);\n            current = current.mixingFrom;\n            interrupt = false;\n          } else this.disposeNext(current);\n        }\n\n        var entry = this.trackEntry(trackIndex, animation, loop, current);\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n        return entry;\n      };\n\n      AnimationState.prototype.addAnimation = function (trackIndex, animationName, loop, delay) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        if (animation == null) throw new Error(\"Animation not found: \" + animationName);\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n      };\n\n      AnimationState.prototype.addAnimationWith = function (trackIndex, animation, loop, delay) {\n        if (animation == null) throw new Error(\"animation cannot be null.\");\n        var last = this.expandToIndex(trackIndex);\n\n        if (last != null) {\n          while (last.next != null) last = last.next;\n        }\n\n        var entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (last == null) {\n          this.setCurrent(trackIndex, entry, true);\n          this.queue.drain();\n        } else {\n          last.next = entry;\n\n          if (delay <= 0) {\n            var duration = last.animationEnd - last.animationStart;\n\n            if (duration != 0) {\n              if (last.loop) delay += duration * (1 + (last.trackTime / duration | 0));else delay += Math.max(duration, last.trackTime);\n              delay -= this.data.getMix(last.animation, animation);\n            } else delay = last.trackTime;\n          }\n        }\n\n        entry.delay = delay;\n        return entry;\n      };\n\n      AnimationState.prototype.setEmptyAnimation = function (trackIndex, mixDuration) {\n        var entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation, false);\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n        return entry;\n      };\n\n      AnimationState.prototype.addEmptyAnimation = function (trackIndex, mixDuration, delay) {\n        if (delay <= 0) delay -= mixDuration;\n        var entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation, false, delay);\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n        return entry;\n      };\n\n      AnimationState.prototype.setEmptyAnimations = function (mixDuration) {\n        var oldDrainDisabled = this.queue.drainDisabled;\n        this.queue.drainDisabled = true;\n\n        for (var i = 0, n = this.tracks.length; i < n; i++) {\n          var current = this.tracks[i];\n          if (current != null) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n      };\n\n      AnimationState.prototype.expandToIndex = function (index) {\n        if (index < this.tracks.length) return this.tracks[index];\n        core.Utils.ensureArrayCapacity(this.tracks, index - this.tracks.length + 1, null);\n        this.tracks.length = index + 1;\n        return null;\n      };\n\n      AnimationState.prototype.trackEntry = function (trackIndex, animation, loop, last) {\n        var entry = this.trackEntryPool.obtain();\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n        entry.alpha = 1;\n        entry.interruptAlpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = last == null ? 0 : this.data.getMix(last.animation, animation);\n        return entry;\n      };\n\n      AnimationState.prototype.disposeNext = function (entry) {\n        var next = entry.next;\n\n        while (next != null) {\n          this.queue.dispose(next);\n          next = next.next;\n        }\n\n        entry.next = null;\n      };\n\n      AnimationState.prototype._animationsChanged = function () {\n        this.animationsChanged = false;\n        this.propertyIDs.clear();\n\n        for (var i = 0, n = this.tracks.length; i < n; i++) {\n          var entry = this.tracks[i];\n          if (entry == null) continue;\n\n          while (entry.mixingFrom != null) entry = entry.mixingFrom;\n\n          do {\n            if (entry.mixingFrom == null || entry.mixBlend != core.MixBlend.add) this.setTimelineModes(entry);\n            entry = entry.mixingTo;\n          } while (entry != null);\n        }\n      };\n\n      AnimationState.prototype.setTimelineModes = function (entry) {\n        var to = entry.mixingTo;\n        var timelines = entry.animation.timelines;\n        var timelinesCount = entry.animation.timelines.length;\n        var timelineMode = core.Utils.setArraySize(entry.timelineMode, timelinesCount);\n        entry.timelineHoldMix.length = 0;\n        var timelineDipMix = core.Utils.setArraySize(entry.timelineHoldMix, timelinesCount);\n        var propertyIDs = this.propertyIDs;\n\n        if (to != null && to.holdPrevious) {\n          for (var i = 0; i < timelinesCount; i++) {\n            propertyIDs.add(timelines[i].getPropertyId());\n            timelineMode[i] = AnimationState.HOLD;\n          }\n\n          return;\n        }\n\n        outer: for (var i = 0; i < timelinesCount; i++) {\n          var id = timelines[i].getPropertyId();\n          if (!propertyIDs.add(id)) timelineMode[i] = AnimationState.SUBSEQUENT;else if (to == null || !this.hasTimeline(to, id)) timelineMode[i] = AnimationState.FIRST;else {\n            for (var next = to.mixingTo; next != null; next = next.mixingTo) {\n              if (this.hasTimeline(next, id)) continue;\n\n              if (entry.mixDuration > 0) {\n                timelineMode[i] = AnimationState.HOLD_MIX;\n                timelineDipMix[i] = next;\n                continue outer;\n              }\n\n              break;\n            }\n\n            timelineMode[i] = AnimationState.HOLD;\n          }\n        }\n      };\n\n      AnimationState.prototype.hasTimeline = function (entry, id) {\n        var timelines = entry.animation.timelines;\n\n        for (var i = 0, n = timelines.length; i < n; i++) if (timelines[i].getPropertyId() == id) return true;\n\n        return false;\n      };\n\n      AnimationState.prototype.getCurrent = function (trackIndex) {\n        if (trackIndex >= this.tracks.length) return null;\n        return this.tracks[trackIndex];\n      };\n\n      AnimationState.prototype.addListener = function (listener) {\n        if (listener == null) throw new Error(\"listener cannot be null.\");\n        this.listeners.push(listener);\n      };\n\n      AnimationState.prototype.removeListener = function (listener) {\n        var index = this.listeners.indexOf(listener);\n        if (index >= 0) this.listeners.splice(index, 1);\n      };\n\n      AnimationState.prototype.clearListeners = function () {\n        this.listeners.length = 0;\n      };\n\n      AnimationState.prototype.clearListenerNotifications = function () {\n        this.queue.clear();\n      };\n\n      AnimationState.prototype.setAnimationByName = function (trackIndex, animationName, loop) {\n        if (!AnimationState.deprecatedWarning1) {\n          AnimationState.deprecatedWarning1 = true;\n          console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n        }\n\n        this.setAnimation(trackIndex, animationName, loop);\n      };\n\n      AnimationState.prototype.addAnimationByName = function (trackIndex, animationName, loop, delay) {\n        if (!AnimationState.deprecatedWarning2) {\n          AnimationState.deprecatedWarning2 = true;\n          console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n        }\n\n        this.addAnimation(trackIndex, animationName, loop, delay);\n      };\n\n      AnimationState.prototype.hasAnimation = function (animationName) {\n        var animation = this.data.skeletonData.findAnimation(animationName);\n        return animation !== null;\n      };\n\n      AnimationState.prototype.hasAnimationByName = function (animationName) {\n        if (!AnimationState.deprecatedWarning3) {\n          AnimationState.deprecatedWarning3 = true;\n          console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n        }\n\n        return this.hasAnimation(animationName);\n      };\n\n      AnimationState.emptyAnimation = new core.Animation(\"<empty>\", [], 0);\n      AnimationState.SUBSEQUENT = 0;\n      AnimationState.FIRST = 1;\n      AnimationState.HOLD = 2;\n      AnimationState.HOLD_MIX = 3;\n      AnimationState.deprecatedWarning1 = false;\n      AnimationState.deprecatedWarning2 = false;\n      AnimationState.deprecatedWarning3 = false;\n      return AnimationState;\n    }();\n\n    core.AnimationState = AnimationState;\n\n    var TrackEntry = function () {\n      function TrackEntry() {\n        this.mixBlend = core.MixBlend.replace;\n        this.timelineMode = new Array();\n        this.timelineHoldMix = new Array();\n        this.timelinesRotation = new Array();\n      }\n\n      TrackEntry.prototype.reset = function () {\n        this.next = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n      };\n\n      TrackEntry.prototype.getAnimationTime = function () {\n        if (this.loop) {\n          var duration = this.animationEnd - this.animationStart;\n          if (duration == 0) return this.animationStart;\n          return this.trackTime % duration + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n      };\n\n      TrackEntry.prototype.setAnimationLast = function (animationLast) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n      };\n\n      TrackEntry.prototype.isComplete = function () {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n      };\n\n      TrackEntry.prototype.resetRotationDirections = function () {\n        this.timelinesRotation.length = 0;\n      };\n\n      Object.defineProperty(TrackEntry.prototype, \"time\", {\n        get: function () {\n          if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n          }\n\n          return this.trackTime;\n        },\n        set: function (value) {\n          if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n          }\n\n          this.trackTime = value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TrackEntry.prototype, \"endTime\", {\n        get: function () {\n          if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n          }\n\n          return this.trackTime;\n        },\n        set: function (value) {\n          if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n          }\n\n          this.trackTime = value;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      TrackEntry.prototype.loopsCount = function () {\n        return Math.floor(this.trackTime / this.trackEnd);\n      };\n\n      TrackEntry.deprecatedWarning1 = false;\n      TrackEntry.deprecatedWarning2 = false;\n      return TrackEntry;\n    }();\n\n    core.TrackEntry = TrackEntry;\n\n    var EventQueue = function () {\n      function EventQueue(animState) {\n        this.objects = [];\n        this.drainDisabled = false;\n        this.animState = animState;\n      }\n\n      EventQueue.prototype.start = function (entry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n      };\n\n      EventQueue.prototype.interrupt = function (entry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n      };\n\n      EventQueue.prototype.end = function (entry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n      };\n\n      EventQueue.prototype.dispose = function (entry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n      };\n\n      EventQueue.prototype.complete = function (entry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n      };\n\n      EventQueue.prototype.event = function (entry, event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n      };\n\n      EventQueue.prototype.deprecateStuff = function () {\n        if (!EventQueue.deprecatedWarning1) {\n          EventQueue.deprecatedWarning1 = true;\n          console.warn(\"Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'\");\n        }\n\n        return true;\n      };\n\n      EventQueue.prototype.drain = function () {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n        var objects = this.objects;\n        var listeners = this.animState.listeners;\n\n        for (var i = 0; i < objects.length; i += 2) {\n          var type = objects[i];\n          var entry = objects[i + 1];\n\n          switch (type) {\n            case EventType.start:\n              if (entry.listener != null && entry.listener.start) entry.listener.start(entry);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].start) listeners[ii].start(entry);\n\n              entry.onStart && this.deprecateStuff() && entry.onStart(entry.trackIndex);\n              this.animState.onStart && this.deprecateStuff() && this.deprecateStuff && this.animState.onStart(entry.trackIndex);\n              break;\n\n            case EventType.interrupt:\n              if (entry.listener != null && entry.listener.interrupt) entry.listener.interrupt(entry);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].interrupt) listeners[ii].interrupt(entry);\n\n              break;\n\n            case EventType.end:\n              if (entry.listener != null && entry.listener.end) entry.listener.end(entry);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].end) listeners[ii].end(entry);\n\n              entry.onEnd && this.deprecateStuff() && entry.onEnd(entry.trackIndex);\n              this.animState.onEnd && this.deprecateStuff() && this.animState.onEnd(entry.trackIndex);\n\n            case EventType.dispose:\n              if (entry.listener != null && entry.listener.dispose) entry.listener.dispose(entry);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].dispose) listeners[ii].dispose(entry);\n\n              this.animState.trackEntryPool.free(entry);\n              break;\n\n            case EventType.complete:\n              if (entry.listener != null && entry.listener.complete) entry.listener.complete(entry);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].complete) listeners[ii].complete(entry);\n\n              var count = core.MathUtils.toInt(entry.loopsCount());\n              entry.onComplete && this.deprecateStuff() && entry.onComplete(entry.trackIndex, count);\n              this.animState.onComplete && this.deprecateStuff() && this.animState.onComplete(entry.trackIndex, count);\n              break;\n\n            case EventType.event:\n              var event_3 = objects[i++ + 2];\n              if (entry.listener != null && entry.listener.event) entry.listener.event(entry, event_3);\n\n              for (var ii = 0; ii < listeners.length; ii++) if (listeners[ii].event) listeners[ii].event(entry, event_3);\n\n              entry.onEvent && this.deprecateStuff() && entry.onEvent(entry.trackIndex, event_3);\n              this.animState.onEvent && this.deprecateStuff() && this.animState.onEvent(entry.trackIndex, event_3);\n              break;\n          }\n        }\n\n        this.clear();\n        this.drainDisabled = false;\n      };\n\n      EventQueue.prototype.clear = function () {\n        this.objects.length = 0;\n      };\n\n      EventQueue.deprecatedWarning1 = false;\n      return EventQueue;\n    }();\n\n    core.EventQueue = EventQueue;\n    var EventType;\n\n    (function (EventType) {\n      EventType[EventType[\"start\"] = 0] = \"start\";\n      EventType[EventType[\"interrupt\"] = 1] = \"interrupt\";\n      EventType[EventType[\"end\"] = 2] = \"end\";\n      EventType[EventType[\"dispose\"] = 3] = \"dispose\";\n      EventType[EventType[\"complete\"] = 4] = \"complete\";\n      EventType[EventType[\"event\"] = 5] = \"event\";\n    })(EventType = core.EventType || (core.EventType = {}));\n\n    var AnimationStateAdapter2 = function () {\n      function AnimationStateAdapter2() {}\n\n      AnimationStateAdapter2.prototype.start = function (entry) {};\n\n      AnimationStateAdapter2.prototype.interrupt = function (entry) {};\n\n      AnimationStateAdapter2.prototype.end = function (entry) {};\n\n      AnimationStateAdapter2.prototype.dispose = function (entry) {};\n\n      AnimationStateAdapter2.prototype.complete = function (entry) {};\n\n      AnimationStateAdapter2.prototype.event = function (entry, event) {};\n\n      return AnimationStateAdapter2;\n    }();\n\n    core.AnimationStateAdapter2 = AnimationStateAdapter2;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var AnimationStateData = function () {\n      function AnimationStateData(skeletonData) {\n        this.animationToMixTime = {};\n        this.defaultMix = 0;\n        if (skeletonData == null) throw new Error(\"skeletonData cannot be null.\");\n        this.skeletonData = skeletonData;\n      }\n\n      AnimationStateData.prototype.setMix = function (fromName, toName, duration) {\n        var from = this.skeletonData.findAnimation(fromName);\n        if (from == null) throw new Error(\"Animation not found: \" + fromName);\n        var to = this.skeletonData.findAnimation(toName);\n        if (to == null) throw new Error(\"Animation not found: \" + toName);\n        this.setMixWith(from, to, duration);\n      };\n\n      AnimationStateData.prototype.setMixByName = function (fromName, toName, duration) {\n        if (!AnimationStateData.deprecatedWarning1) {\n          AnimationStateData.deprecatedWarning1 = true;\n          console.warn(\"Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.\");\n        }\n\n        this.setMix(fromName, toName, duration);\n      };\n\n      AnimationStateData.prototype.setMixWith = function (from, to, duration) {\n        if (from == null) throw new Error(\"from cannot be null.\");\n        if (to == null) throw new Error(\"to cannot be null.\");\n        var key = from.name + \".\" + to.name;\n        this.animationToMixTime[key] = duration;\n      };\n\n      AnimationStateData.prototype.getMix = function (from, to) {\n        var key = from.name + \".\" + to.name;\n        var value = this.animationToMixTime[key];\n        return value === undefined ? this.defaultMix : value;\n      };\n\n      AnimationStateData.deprecatedWarning1 = false;\n      return AnimationStateData;\n    }();\n\n    core.AnimationStateData = AnimationStateData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var AtlasAttachmentLoader = function () {\n      function AtlasAttachmentLoader(atlas) {\n        this.atlas = atlas;\n      }\n\n      AtlasAttachmentLoader.prototype.newRegionAttachment = function (skin, name, path) {\n        var region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (region attachment: \" + name + \")\");\n        var attachment = new core.RegionAttachment(name);\n        attachment.region = region;\n        return attachment;\n      };\n\n      AtlasAttachmentLoader.prototype.newMeshAttachment = function (skin, name, path) {\n        var region = this.atlas.findRegion(path);\n        if (region == null) throw new Error(\"Region not found in atlas: \" + path + \" (mesh attachment: \" + name + \")\");\n        var attachment = new core.MeshAttachment(name);\n        attachment.region = region;\n        return attachment;\n      };\n\n      AtlasAttachmentLoader.prototype.newBoundingBoxAttachment = function (skin, name) {\n        return new core.BoundingBoxAttachment(name);\n      };\n\n      AtlasAttachmentLoader.prototype.newPathAttachment = function (skin, name) {\n        return new core.PathAttachment(name);\n      };\n\n      AtlasAttachmentLoader.prototype.newPointAttachment = function (skin, name) {\n        return new core.PointAttachment(name);\n      };\n\n      AtlasAttachmentLoader.prototype.newClippingAttachment = function (skin, name) {\n        return new core.ClippingAttachment(name);\n      };\n\n      return AtlasAttachmentLoader;\n    }();\n\n    core.AtlasAttachmentLoader = AtlasAttachmentLoader;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var BlendMode;\n\n    (function (BlendMode) {\n      BlendMode[BlendMode[\"Normal\"] = 0] = \"Normal\";\n      BlendMode[BlendMode[\"Additive\"] = 1] = \"Additive\";\n      BlendMode[BlendMode[\"Multiply\"] = 2] = \"Multiply\";\n      BlendMode[BlendMode[\"Screen\"] = 3] = \"Screen\";\n    })(BlendMode = core.BlendMode || (core.BlendMode = {}));\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Bone = function () {\n      function Bone(data, skeleton, parent) {\n        this.matrix = new PIXI.Matrix();\n        this.children = new Array();\n        this.x = 0;\n        this.y = 0;\n        this.rotation = 0;\n        this.scaleX = 0;\n        this.scaleY = 0;\n        this.shearX = 0;\n        this.shearY = 0;\n        this.ax = 0;\n        this.ay = 0;\n        this.arotation = 0;\n        this.ascaleX = 0;\n        this.ascaleY = 0;\n        this.ashearX = 0;\n        this.ashearY = 0;\n        this.appliedValid = false;\n        this.sorted = false;\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n      }\n\n      Object.defineProperty(Bone.prototype, \"worldX\", {\n        get: function () {\n          return this.matrix.tx;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(Bone.prototype, \"worldY\", {\n        get: function () {\n          return this.matrix.ty;\n        },\n        enumerable: true,\n        configurable: true\n      });\n\n      Bone.prototype.update = function () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n      };\n\n      Bone.prototype.updateWorldTransform = function () {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n      };\n\n      Bone.prototype.updateWorldTransformWith = function (x, y, rotation, scaleX, scaleY, shearX, shearY) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n        this.appliedValid = true;\n        var parent = this.parent;\n        var m = this.matrix;\n        var sx = this.skeleton.scaleX;\n        var sy = Bone.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (parent == null) {\n          if (Bone.yDown) {\n            rotation = -rotation;\n            this.arotation = rotation;\n          }\n\n          var skeleton = this.skeleton;\n          var rotationY = rotation + 90 + shearY;\n          m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n          m.c = core.MathUtils.cosDeg(rotationY) * scaleY * sy;\n          m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX * sx;\n          m.d = core.MathUtils.sinDeg(rotationY) * scaleY * sy;\n          m.tx = x * sx + skeleton.x;\n          m.ty = y * sy + skeleton.y;\n          return;\n        }\n\n        var pa = parent.matrix.a,\n            pb = parent.matrix.c,\n            pc = parent.matrix.b,\n            pd = parent.matrix.d;\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n\n        switch (this.data.transformMode) {\n          case core.TransformMode.Normal:\n            {\n              var rotationY = rotation + 90 + shearY;\n              var la = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n              var lb = core.MathUtils.cosDeg(rotationY) * scaleY;\n              var lc = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n              var ld = core.MathUtils.sinDeg(rotationY) * scaleY;\n              m.a = pa * la + pb * lc;\n              m.c = pa * lb + pb * ld;\n              m.b = pc * la + pd * lc;\n              m.d = pc * lb + pd * ld;\n              return;\n            }\n\n          case core.TransformMode.OnlyTranslation:\n            {\n              var rotationY = rotation + 90 + shearY;\n              m.a = core.MathUtils.cosDeg(rotation + shearX) * scaleX;\n              m.c = core.MathUtils.cosDeg(rotationY) * scaleY;\n              m.b = core.MathUtils.sinDeg(rotation + shearX) * scaleX;\n              m.d = core.MathUtils.sinDeg(rotationY) * scaleY;\n              break;\n            }\n\n          case core.TransformMode.NoRotationOrReflection:\n            {\n              var s = pa * pa + pc * pc;\n              var prx = 0;\n\n              if (s > 0.0001) {\n                s = Math.abs(pa * pd - pb * pc) / s;\n                pb = pc * s;\n                pd = pa * s;\n                prx = Math.atan2(pc, pa) * core.MathUtils.radDeg;\n              } else {\n                pa = 0;\n                pc = 0;\n                prx = 90 - Math.atan2(pd, pb) * core.MathUtils.radDeg;\n              }\n\n              var rx = rotation + shearX - prx;\n              var ry = rotation + shearY - prx + 90;\n              var la = core.MathUtils.cosDeg(rx) * scaleX;\n              var lb = core.MathUtils.cosDeg(ry) * scaleY;\n              var lc = core.MathUtils.sinDeg(rx) * scaleX;\n              var ld = core.MathUtils.sinDeg(ry) * scaleY;\n              m.a = pa * la - pb * lc;\n              m.c = pa * lb - pb * ld;\n              m.b = pc * la + pd * lc;\n              m.d = pc * lb + pd * ld;\n              break;\n            }\n\n          case core.TransformMode.NoScale:\n          case core.TransformMode.NoScaleOrReflection:\n            {\n              var cos = core.MathUtils.cosDeg(rotation);\n              var sin = core.MathUtils.sinDeg(rotation);\n              var za = (pa * cos + pb * sin) / sx;\n              var zc = (pc * cos + pd * sin) / sy;\n              var s = Math.sqrt(za * za + zc * zc);\n              if (s > 0.00001) s = 1 / s;\n              za *= s;\n              zc *= s;\n              s = Math.sqrt(za * za + zc * zc);\n              if (this.data.transformMode == core.TransformMode.NoScale && pa * pd - pb * pc < 0 != (Bone.yDown ? this.skeleton.scaleX < 0 != this.skeleton.scaleY > 0 : this.skeleton.scaleX < 0 != this.skeleton.scaleY < 0)) s = -s;\n              var r = Math.PI / 2 + Math.atan2(zc, za);\n              var zb = Math.cos(r) * s;\n              var zd = Math.sin(r) * s;\n              var la = core.MathUtils.cosDeg(shearX) * scaleX;\n              var lb = core.MathUtils.cosDeg(90 + shearY) * scaleY;\n              var lc = core.MathUtils.sinDeg(shearX) * scaleX;\n              var ld = core.MathUtils.sinDeg(90 + shearY) * scaleY;\n              m.a = za * la + zb * lc;\n              m.c = za * lb + zb * ld;\n              m.b = zc * la + zd * lc;\n              m.d = zc * lb + zd * ld;\n              break;\n            }\n        }\n\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n      };\n\n      Bone.prototype.setToSetupPose = function () {\n        var data = this.data;\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n      };\n\n      Bone.prototype.getWorldRotationX = function () {\n        return Math.atan2(this.matrix.b, this.matrix.a) * core.MathUtils.radDeg;\n      };\n\n      Bone.prototype.getWorldRotationY = function () {\n        return Math.atan2(this.matrix.d, this.matrix.c) * core.MathUtils.radDeg;\n      };\n\n      Bone.prototype.getWorldScaleX = function () {\n        var m = this.matrix;\n        return Math.sqrt(m.a * m.a + m.c * m.c);\n      };\n\n      Bone.prototype.getWorldScaleY = function () {\n        var m = this.matrix;\n        return Math.sqrt(m.b * m.b + m.d * m.d);\n      };\n\n      Bone.prototype.updateAppliedTransform = function () {\n        this.appliedValid = true;\n        var parent = this.parent;\n        var m = this.matrix;\n\n        if (parent == null) {\n          this.ax = m.tx;\n          this.ay = m.ty;\n          this.arotation = Math.atan2(m.b, m.a) * core.MathUtils.radDeg;\n          this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n          this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n          this.ashearX = 0;\n          this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * core.MathUtils.radDeg;\n          return;\n        }\n\n        var pm = parent.matrix;\n        var pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        var dx = m.tx - pm.tx,\n            dy = m.ty - pm.ty;\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        var ia = pid * pm.d;\n        var id = pid * pm.a;\n        var ib = pid * pm.c;\n        var ic = pid * pm.b;\n        var ra = ia * m.a - ib * m.b;\n        var rb = ia * m.c - ib * m.d;\n        var rc = id * m.b - ic * m.a;\n        var rd = id * m.d - ic * m.c;\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n\n        if (this.ascaleX > 0.0001) {\n          var det = ra * rd - rb * rc;\n          this.ascaleY = det / this.ascaleX;\n          this.ashearY = Math.atan2(ra * rb + rc * rd, det) * core.MathUtils.radDeg;\n          this.arotation = Math.atan2(rc, ra) * core.MathUtils.radDeg;\n        } else {\n          this.ascaleX = 0;\n          this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n          this.ashearY = 0;\n          this.arotation = 90 - Math.atan2(rd, rb) * core.MathUtils.radDeg;\n        }\n      };\n\n      Bone.prototype.worldToLocal = function (world) {\n        var m = this.matrix;\n        var a = m.a,\n            b = m.c,\n            c = m.b,\n            d = m.d;\n        var invDet = 1 / (a * d - b * c);\n        var x = world.x - m.tx,\n            y = world.y - m.ty;\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n        return world;\n      };\n\n      Bone.prototype.localToWorld = function (local) {\n        var m = this.matrix;\n        var x = local.x,\n            y = local.y;\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n        return local;\n      };\n\n      Bone.prototype.worldToLocalRotation = function (worldRotation) {\n        var sin = core.MathUtils.sinDeg(worldRotation),\n            cos = core.MathUtils.cosDeg(worldRotation);\n        var mat = this.matrix;\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * core.MathUtils.radDeg;\n      };\n\n      Bone.prototype.localToWorldRotation = function (localRotation) {\n        var sin = core.MathUtils.sinDeg(localRotation),\n            cos = core.MathUtils.cosDeg(localRotation);\n        var mat = this.matrix;\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * core.MathUtils.radDeg;\n      };\n\n      Bone.prototype.rotateWorld = function (degrees) {\n        var mat = this.matrix;\n        var a = mat.a,\n            b = mat.c,\n            c = mat.b,\n            d = mat.d;\n        var cos = core.MathUtils.cosDeg(degrees),\n            sin = core.MathUtils.sinDeg(degrees);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n        this.appliedValid = false;\n      };\n\n      Bone.yDown = false;\n      return Bone;\n    }();\n\n    core.Bone = Bone;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var BoneData = function () {\n      function BoneData(index, name, parent) {\n        this.x = 0;\n        this.y = 0;\n        this.rotation = 0;\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.shearX = 0;\n        this.shearY = 0;\n        this.transformMode = TransformMode.Normal;\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.parent = parent;\n      }\n\n      return BoneData;\n    }();\n\n    core.BoneData = BoneData;\n    var TransformMode;\n\n    (function (TransformMode) {\n      TransformMode[TransformMode[\"Normal\"] = 0] = \"Normal\";\n      TransformMode[TransformMode[\"OnlyTranslation\"] = 1] = \"OnlyTranslation\";\n      TransformMode[TransformMode[\"NoRotationOrReflection\"] = 2] = \"NoRotationOrReflection\";\n      TransformMode[TransformMode[\"NoScale\"] = 3] = \"NoScale\";\n      TransformMode[TransformMode[\"NoScaleOrReflection\"] = 4] = \"NoScaleOrReflection\";\n    })(TransformMode = core.TransformMode || (core.TransformMode = {}));\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Event = function () {\n      function Event(time, data) {\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.time = time;\n        this.data = data;\n      }\n\n      return Event;\n    }();\n\n    core.Event = Event;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var EventData = function () {\n      function EventData(name) {\n        this.name = name;\n      }\n\n      return EventData;\n    }();\n\n    core.EventData = EventData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var IkConstraint = function () {\n      function IkConstraint(data, skeleton) {\n        this.bendDirection = 0;\n        this.compress = false;\n        this.stretch = false;\n        this.mix = 1;\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.mix = data.mix;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n        this.bones = new Array();\n\n        for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n        this.target = skeleton.findBone(data.target.name);\n      }\n\n      IkConstraint.prototype.getOrder = function () {\n        return this.data.order;\n      };\n\n      IkConstraint.prototype.apply = function () {\n        this.update();\n      };\n\n      IkConstraint.prototype.update = function () {\n        var target = this.target;\n        var bones = this.bones;\n\n        switch (bones.length) {\n          case 1:\n            this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n            break;\n\n          case 2:\n            this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.mix);\n            break;\n        }\n      };\n\n      IkConstraint.prototype.apply1 = function (bone, targetX, targetY, compress, stretch, uniform, alpha) {\n        if (!bone.appliedValid) bone.updateAppliedTransform();\n        var p = bone.parent.matrix;\n        var id = 1 / (p.a * p.d - p.b * p.c);\n        var x = targetX - p.tx,\n            y = targetY - p.ty;\n        var tx = (x * p.d - y * p.c) * id - bone.ax,\n            ty = (y * p.a - x * p.b) * id - bone.ay;\n        var rotationIK = Math.atan2(ty, tx) * core.MathUtils.radDeg - bone.ashearX - bone.arotation;\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;\n        var sx = bone.ascaleX,\n            sy = bone.ascaleY;\n\n        if (compress || stretch) {\n          var b = bone.data.length * sx,\n              dd = Math.sqrt(tx * tx + ty * ty);\n\n          if (compress && dd < b || stretch && dd > b && b > 0.0001) {\n            var s = (dd / b - 1) * alpha + 1;\n            sx *= s;\n            if (uniform) sy *= s;\n          }\n        }\n\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n      };\n\n      IkConstraint.prototype.apply2 = function (parent, child, targetX, targetY, bendDir, stretch, alpha) {\n        if (alpha == 0) {\n          child.updateWorldTransform();\n          return;\n        }\n\n        if (!parent.appliedValid) parent.updateAppliedTransform();\n        if (!child.appliedValid) child.updateAppliedTransform();\n        var px = parent.ax,\n            py = parent.ay,\n            psx = parent.ascaleX,\n            sx = psx,\n            psy = parent.ascaleY,\n            csx = child.ascaleX;\n        var pmat = parent.matrix;\n        var os1 = 0,\n            os2 = 0,\n            s2 = 0;\n\n        if (psx < 0) {\n          psx = -psx;\n          os1 = 180;\n          s2 = -1;\n        } else {\n          os1 = 0;\n          s2 = 1;\n        }\n\n        if (psy < 0) {\n          psy = -psy;\n          s2 = -s2;\n        }\n\n        if (csx < 0) {\n          csx = -csx;\n          os2 = 180;\n        } else os2 = 0;\n\n        var cx = child.ax,\n            cy = 0,\n            cwx = 0,\n            cwy = 0,\n            a = pmat.a,\n            b = pmat.c,\n            c = pmat.b,\n            d = pmat.d;\n        var u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u) {\n          cy = 0;\n          cwx = a * cx + pmat.tx;\n          cwy = c * cx + pmat.ty;\n        } else {\n          cy = child.ay;\n          cwx = a * cx + b * cy + pmat.tx;\n          cwy = c * cx + d * cy + pmat.ty;\n        }\n\n        var pp = parent.parent.matrix;\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        var id = 1 / (a * d - b * c),\n            x = targetX - pp.tx,\n            y = targetY - pp.ty;\n        var tx = (x * d - y * b) * id - px,\n            ty = (y * a - x * c) * id - py,\n            dd = tx * tx + ty * ty;\n        x = cwx - pp.tx;\n        y = cwy - pp.ty;\n        var dx = (x * d - y * b) * id - px,\n            dy = (y * a - x * c) * id - py;\n        var l1 = Math.sqrt(dx * dx + dy * dy),\n            l2 = child.data.length * csx,\n            a1 = 0,\n            a2 = 0;\n\n        outer: if (u) {\n          l2 *= psx;\n          var cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n          if (cos < -1) cos = -1;else if (cos > 1) {\n            cos = 1;\n            if (stretch && l1 + l2 > 0.0001) sx *= (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n          }\n          a2 = Math.acos(cos) * bendDir;\n          a = l1 + l2 * cos;\n          b = l2 * Math.sin(a2);\n          a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n          a = psx * l2;\n          b = psy * l2;\n          var aa = a * a,\n              bb = b * b,\n              ta = Math.atan2(ty, tx);\n          c = bb * l1 * l1 + aa * dd - aa * bb;\n          var c1 = -2 * bb * l1,\n              c2 = bb - aa;\n          d = c1 * c1 - 4 * c2 * c;\n\n          if (d >= 0) {\n            var q = Math.sqrt(d);\n            if (c1 < 0) q = -q;\n            q = -(c1 + q) / 2;\n            var r0 = q / c2,\n                r1 = c / q;\n            var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n            if (r * r <= dd) {\n              y = Math.sqrt(dd - r * r) * bendDir;\n              a1 = ta - Math.atan2(y, r);\n              a2 = Math.atan2(y / psy, (r - l1) / psx);\n              break outer;\n            }\n          }\n\n          var minAngle = core.MathUtils.PI,\n              minX = l1 - a,\n              minDist = minX * minX,\n              minY = 0;\n          var maxAngle = 0,\n              maxX = l1 + a,\n              maxDist = maxX * maxX,\n              maxY = 0;\n          c = -a * l1 / (aa - bb);\n\n          if (c >= -1 && c <= 1) {\n            c = Math.acos(c);\n            x = a * Math.cos(c) + l1;\n            y = b * Math.sin(c);\n            d = x * x + y * y;\n\n            if (d < minDist) {\n              minAngle = c;\n              minDist = d;\n              minX = x;\n              minY = y;\n            }\n\n            if (d > maxDist) {\n              maxAngle = c;\n              maxDist = d;\n              maxX = x;\n              maxY = y;\n            }\n          }\n\n          if (dd <= (minDist + maxDist) / 2) {\n            a1 = ta - Math.atan2(minY * bendDir, minX);\n            a2 = minAngle * bendDir;\n          } else {\n            a1 = ta - Math.atan2(maxY * bendDir, maxX);\n            a2 = maxAngle * bendDir;\n          }\n        }\n\n        var os = Math.atan2(cy, cx) * s2;\n        var rotation = parent.arotation;\n        a1 = (a1 - os) * core.MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;else if (a1 < -180) a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, parent.ascaleY, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * core.MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;else if (a2 < -180) a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      };\n\n      return IkConstraint;\n    }();\n\n    core.IkConstraint = IkConstraint;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var IkConstraintData = function () {\n      function IkConstraintData(name) {\n        this.order = 0;\n        this.bones = new Array();\n        this.bendDirection = 1;\n        this.compress = false;\n        this.stretch = false;\n        this.uniform = false;\n        this.mix = 1;\n        this.name = name;\n      }\n\n      return IkConstraintData;\n    }();\n\n    core.IkConstraintData = IkConstraintData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var PathConstraint = function () {\n      function PathConstraint(data, skeleton) {\n        this.position = 0;\n        this.spacing = 0;\n        this.rotateMix = 0;\n        this.translateMix = 0;\n        this.spaces = new Array();\n        this.positions = new Array();\n        this.world = new Array();\n        this.curves = new Array();\n        this.lengths = new Array();\n        this.segments = new Array();\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.bones = new Array();\n\n        for (var i = 0, n = data.bones.length; i < n; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n        this.target = skeleton.findSlot(data.target.name);\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n      }\n\n      PathConstraint.prototype.apply = function () {\n        this.update();\n      };\n\n      PathConstraint.prototype.update = function () {\n        var attachment = this.target.getAttachment();\n        if (!(attachment instanceof core.PathAttachment)) return;\n        var rotateMix = this.rotateMix,\n            translateMix = this.translateMix;\n        var translate = translateMix > 0,\n            rotate = rotateMix > 0;\n        if (!translate && !rotate) return;\n        var data = this.data;\n        var spacingMode = data.spacingMode;\n        var lengthSpacing = spacingMode == core.SpacingMode.Length;\n        var rotateMode = data.rotateMode;\n        var tangents = rotateMode == core.RotateMode.Tangent,\n            scale = rotateMode == core.RotateMode.ChainScale;\n        var boneCount = this.bones.length,\n            spacesCount = tangents ? boneCount : boneCount + 1;\n        var bones = this.bones;\n        var spaces = core.Utils.setArraySize(this.spaces, spacesCount),\n            lengths = null;\n        var spacing = this.spacing;\n\n        if (scale || lengthSpacing) {\n          if (scale) lengths = core.Utils.setArraySize(this.lengths, boneCount);\n\n          for (var i = 0, n = spacesCount - 1; i < n;) {\n            var bone = bones[i];\n            var setupLength = bone.data.length;\n\n            if (setupLength < PathConstraint.epsilon) {\n              if (scale) lengths[i] = 0;\n              spaces[++i] = 0;\n            } else {\n              var x = setupLength * bone.matrix.a,\n                  y = setupLength * bone.matrix.b;\n              var length_1 = Math.sqrt(x * x + y * y);\n              if (scale) lengths[i] = length_1;\n              spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length_1 / setupLength;\n            }\n          }\n        } else {\n          for (var i = 1; i < spacesCount; i++) spaces[i] = spacing;\n        }\n\n        var positions = this.computeWorldPositions(attachment, spacesCount, tangents, data.positionMode == core.PositionMode.Percent, spacingMode == core.SpacingMode.Percent);\n        var boneX = positions[0],\n            boneY = positions[1],\n            offsetRotation = data.offsetRotation;\n        var tip = false;\n        if (offsetRotation == 0) tip = rotateMode == core.RotateMode.Chain;else {\n          tip = false;\n          var p = this.target.bone.matrix;\n          offsetRotation *= p.a * p.d - p.b * p.c > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n        }\n\n        for (var i = 0, p = 3; i < boneCount; i++, p += 3) {\n          var bone = bones[i];\n          var mat = bone.matrix;\n          mat.tx += (boneX - mat.tx) * translateMix;\n          mat.ty += (boneY - mat.ty) * translateMix;\n          var x = positions[p],\n              y = positions[p + 1],\n              dx = x - boneX,\n              dy = y - boneY;\n\n          if (scale) {\n            var length_2 = lengths[i];\n\n            if (length_2 != 0) {\n              var s = (Math.sqrt(dx * dx + dy * dy) / length_2 - 1) * rotateMix + 1;\n              mat.a *= s;\n              mat.b *= s;\n            }\n          }\n\n          boneX = x;\n          boneY = y;\n\n          if (rotate) {\n            var a = mat.a,\n                b = mat.c,\n                c = mat.b,\n                d = mat.d,\n                r = 0,\n                cos = 0,\n                sin = 0;\n            if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);\n            r -= Math.atan2(c, a);\n\n            if (tip) {\n              cos = Math.cos(r);\n              sin = Math.sin(r);\n              var length_3 = bone.data.length;\n              boneX += (length_3 * (cos * a - sin * c) - dx) * rotateMix;\n              boneY += (length_3 * (sin * a + cos * c) - dy) * rotateMix;\n            } else {\n              r += offsetRotation;\n            }\n\n            if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n            r *= rotateMix;\n            cos = Math.cos(r);\n            sin = Math.sin(r);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n          }\n\n          bone.appliedValid = false;\n        }\n      };\n\n      PathConstraint.prototype.computeWorldPositions = function (path, spacesCount, tangents, percentPosition, percentSpacing) {\n        var target = this.target;\n        var position = this.position;\n        var spaces = this.spaces,\n            out = core.Utils.setArraySize(this.positions, spacesCount * 3 + 2),\n            world = null;\n        var closed = path.closed;\n        var verticesLength = path.worldVerticesLength,\n            curveCount = verticesLength / 6,\n            prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n          var lengths = path.lengths;\n          curveCount -= closed ? 1 : 2;\n          var pathLength_1 = lengths[curveCount];\n          if (percentPosition) position *= pathLength_1;\n\n          if (percentSpacing) {\n            for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength_1;\n          }\n\n          world = core.Utils.setArraySize(this.world, 8);\n\n          for (var i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n            var space = spaces[i];\n            position += space;\n            var p = position;\n\n            if (closed) {\n              p %= pathLength_1;\n              if (p < 0) p += pathLength_1;\n              curve = 0;\n            } else if (p < 0) {\n              if (prevCurve != PathConstraint.BEFORE) {\n                prevCurve = PathConstraint.BEFORE;\n                path.computeWorldVertices(target, 2, 4, world, 0, 2);\n              }\n\n              this.addBeforePosition(p, world, 0, out, o);\n              continue;\n            } else if (p > pathLength_1) {\n              if (prevCurve != PathConstraint.AFTER) {\n                prevCurve = PathConstraint.AFTER;\n                path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n              }\n\n              this.addAfterPosition(p - pathLength_1, world, 0, out, o);\n              continue;\n            }\n\n            for (;; curve++) {\n              var length_4 = lengths[curve];\n              if (p > length_4) continue;\n              if (curve == 0) p /= length_4;else {\n                var prev = lengths[curve - 1];\n                p = (p - prev) / (length_4 - prev);\n              }\n              break;\n            }\n\n            if (curve != prevCurve) {\n              prevCurve = curve;\n\n              if (closed && curve == curveCount) {\n                path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                path.computeWorldVertices(target, 0, 4, world, 4, 2);\n              } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n            }\n\n            this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n          }\n\n          return out;\n        }\n\n        if (closed) {\n          verticesLength += 2;\n          world = core.Utils.setArraySize(this.world, verticesLength);\n          path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n          path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n          world[verticesLength - 2] = world[0];\n          world[verticesLength - 1] = world[1];\n        } else {\n          curveCount--;\n          verticesLength -= 4;\n          world = core.Utils.setArraySize(this.world, verticesLength);\n          path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        var curves = core.Utils.setArraySize(this.curves, curveCount);\n        var pathLength = 0;\n        var x1 = world[0],\n            y1 = world[1],\n            cx1 = 0,\n            cy1 = 0,\n            cx2 = 0,\n            cy2 = 0,\n            x2 = 0,\n            y2 = 0;\n        var tmpx = 0,\n            tmpy = 0,\n            dddfx = 0,\n            dddfy = 0,\n            ddfx = 0,\n            ddfy = 0,\n            dfx = 0,\n            dfy = 0;\n\n        for (var i = 0, w = 2; i < curveCount; i++, w += 6) {\n          cx1 = world[w];\n          cy1 = world[w + 1];\n          cx2 = world[w + 2];\n          cy2 = world[w + 3];\n          x2 = world[w + 4];\n          y2 = world[w + 5];\n          tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n          tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n          dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n          dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n          ddfx = tmpx * 2 + dddfx;\n          ddfy = tmpy * 2 + dddfy;\n          dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n          dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n          pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          dfx += ddfx;\n          dfy += ddfy;\n          pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          dfx += ddfx + dddfx;\n          dfy += ddfy + dddfy;\n          pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          curves[i] = pathLength;\n          x1 = x2;\n          y1 = y2;\n        }\n\n        if (percentPosition) position *= pathLength;\n\n        if (percentSpacing) {\n          for (var i = 0; i < spacesCount; i++) spaces[i] *= pathLength;\n        }\n\n        var segments = this.segments;\n        var curveLength = 0;\n\n        for (var i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n          var space = spaces[i];\n          position += space;\n          var p = position;\n\n          if (closed) {\n            p %= pathLength;\n            if (p < 0) p += pathLength;\n            curve = 0;\n          } else if (p < 0) {\n            this.addBeforePosition(p, world, 0, out, o);\n            continue;\n          } else if (p > pathLength) {\n            this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n            continue;\n          }\n\n          for (;; curve++) {\n            var length_5 = curves[curve];\n            if (p > length_5) continue;\n            if (curve == 0) p /= length_5;else {\n              var prev = curves[curve - 1];\n              p = (p - prev) / (length_5 - prev);\n            }\n            break;\n          }\n\n          if (curve != prevCurve) {\n            prevCurve = curve;\n            var ii = curve * 6;\n            x1 = world[ii];\n            y1 = world[ii + 1];\n            cx1 = world[ii + 2];\n            cy1 = world[ii + 3];\n            cx2 = world[ii + 4];\n            cy2 = world[ii + 5];\n            x2 = world[ii + 6];\n            y2 = world[ii + 7];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n            curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n            segments[0] = curveLength;\n\n            for (ii = 1; ii < 8; ii++) {\n              dfx += ddfx;\n              dfy += ddfy;\n              ddfx += dddfx;\n              ddfy += dddfy;\n              curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n              segments[ii] = curveLength;\n            }\n\n            dfx += ddfx;\n            dfy += ddfy;\n            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            segments[8] = curveLength;\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            segments[9] = curveLength;\n            segment = 0;\n          }\n\n          p *= curveLength;\n\n          for (;; segment++) {\n            var length_6 = segments[segment];\n            if (p > length_6) continue;\n            if (segment == 0) p /= length_6;else {\n              var prev = segments[segment - 1];\n              p = segment + (p - prev) / (length_6 - prev);\n            }\n            break;\n          }\n\n          this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n        }\n\n        return out;\n      };\n\n      PathConstraint.prototype.addBeforePosition = function (p, temp, i, out, o) {\n        var x1 = temp[i],\n            y1 = temp[i + 1],\n            dx = temp[i + 2] - x1,\n            dy = temp[i + 3] - y1,\n            r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n      };\n\n      PathConstraint.prototype.addAfterPosition = function (p, temp, i, out, o) {\n        var x1 = temp[i + 2],\n            y1 = temp[i + 3],\n            dx = x1 - temp[i],\n            dy = y1 - temp[i + 1],\n            r = Math.atan2(dy, dx);\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n      };\n\n      PathConstraint.prototype.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n        if (p == 0 || isNaN(p)) p = 0.0001;\n        var tt = p * p,\n            ttt = tt * p,\n            u = 1 - p,\n            uu = u * u,\n            uuu = uu * u;\n        var ut = u * p,\n            ut3 = ut * 3,\n            uut3 = u * ut3,\n            utt3 = ut3 * p;\n        var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt,\n            y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n      };\n\n      PathConstraint.prototype.getOrder = function () {\n        return this.data.order;\n      };\n\n      PathConstraint.NONE = -1;\n      PathConstraint.BEFORE = -2;\n      PathConstraint.AFTER = -3;\n      PathConstraint.epsilon = 0.00001;\n      return PathConstraint;\n    }();\n\n    core.PathConstraint = PathConstraint;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var PathConstraintData = function () {\n      function PathConstraintData(name) {\n        this.order = 0;\n        this.bones = new Array();\n        this.name = name;\n      }\n\n      return PathConstraintData;\n    }();\n\n    core.PathConstraintData = PathConstraintData;\n    var PositionMode;\n\n    (function (PositionMode) {\n      PositionMode[PositionMode[\"Fixed\"] = 0] = \"Fixed\";\n      PositionMode[PositionMode[\"Percent\"] = 1] = \"Percent\";\n    })(PositionMode = core.PositionMode || (core.PositionMode = {}));\n\n    var SpacingMode;\n\n    (function (SpacingMode) {\n      SpacingMode[SpacingMode[\"Length\"] = 0] = \"Length\";\n      SpacingMode[SpacingMode[\"Fixed\"] = 1] = \"Fixed\";\n      SpacingMode[SpacingMode[\"Percent\"] = 2] = \"Percent\";\n    })(SpacingMode = core.SpacingMode || (core.SpacingMode = {}));\n\n    var RotateMode;\n\n    (function (RotateMode) {\n      RotateMode[RotateMode[\"Tangent\"] = 0] = \"Tangent\";\n      RotateMode[RotateMode[\"Chain\"] = 1] = \"Chain\";\n      RotateMode[RotateMode[\"ChainScale\"] = 2] = \"ChainScale\";\n    })(RotateMode = core.RotateMode || (core.RotateMode = {}));\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Skeleton = function () {\n      function Skeleton(data) {\n        this._updateCache = new Array();\n        this.updateCacheReset = new Array();\n        this.time = 0;\n        this.scaleX = 1;\n        this.scaleY = 1;\n        this.x = 0;\n        this.y = 0;\n        if (data == null) throw new Error(\"data cannot be null.\");\n        this.data = data;\n        this.bones = new Array();\n\n        for (var i = 0; i < data.bones.length; i++) {\n          var boneData = data.bones[i];\n          var bone = void 0;\n          if (boneData.parent == null) bone = new core.Bone(boneData, this, null);else {\n            var parent_1 = this.bones[boneData.parent.index];\n            bone = new core.Bone(boneData, this, parent_1);\n            parent_1.children.push(bone);\n          }\n          this.bones.push(bone);\n        }\n\n        this.slots = new Array();\n        this.drawOrder = new Array();\n\n        for (var i = 0; i < data.slots.length; i++) {\n          var slotData = data.slots[i];\n          var bone = this.bones[slotData.boneData.index];\n          var slot = new core.Slot(slotData, bone);\n          this.slots.push(slot);\n          this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array();\n\n        for (var i = 0; i < data.ikConstraints.length; i++) {\n          var ikConstraintData = data.ikConstraints[i];\n          this.ikConstraints.push(new core.IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array();\n\n        for (var i = 0; i < data.transformConstraints.length; i++) {\n          var transformConstraintData = data.transformConstraints[i];\n          this.transformConstraints.push(new core.TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array();\n\n        for (var i = 0; i < data.pathConstraints.length; i++) {\n          var pathConstraintData = data.pathConstraints[i];\n          this.pathConstraints.push(new core.PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new core.Color(1, 1, 1, 1);\n        this.updateCache();\n      }\n\n      Skeleton.prototype.updateCache = function () {\n        var updateCache = this._updateCache;\n        updateCache.length = 0;\n        this.updateCacheReset.length = 0;\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) bones[i].sorted = false;\n\n        var ikConstraints = this.ikConstraints;\n        var transformConstraints = this.transformConstraints;\n        var pathConstraints = this.pathConstraints;\n        var ikCount = ikConstraints.length,\n            transformCount = transformConstraints.length,\n            pathCount = pathConstraints.length;\n        var constraintCount = ikCount + transformCount + pathCount;\n\n        outer: for (var i = 0; i < constraintCount; i++) {\n          for (var ii = 0; ii < ikCount; ii++) {\n            var constraint = ikConstraints[ii];\n\n            if (constraint.data.order == i) {\n              this.sortIkConstraint(constraint);\n              continue outer;\n            }\n          }\n\n          for (var ii = 0; ii < transformCount; ii++) {\n            var constraint = transformConstraints[ii];\n\n            if (constraint.data.order == i) {\n              this.sortTransformConstraint(constraint);\n              continue outer;\n            }\n          }\n\n          for (var ii = 0; ii < pathCount; ii++) {\n            var constraint = pathConstraints[ii];\n\n            if (constraint.data.order == i) {\n              this.sortPathConstraint(constraint);\n              continue outer;\n            }\n          }\n        }\n\n        for (var i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n      };\n\n      Skeleton.prototype.sortIkConstraint = function (constraint) {\n        var target = constraint.target;\n        this.sortBone(target);\n        var constrained = constraint.bones;\n        var parent = constrained[0];\n        this.sortBone(parent);\n\n        if (constrained.length > 1) {\n          var child = constrained[constrained.length - 1];\n          if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n        }\n\n        this._updateCache.push(constraint);\n\n        this.sortReset(parent.children);\n        constrained[constrained.length - 1].sorted = true;\n      };\n\n      Skeleton.prototype.sortPathConstraint = function (constraint) {\n        var slot = constraint.target;\n        var slotIndex = slot.data.index;\n        var slotBone = slot.bone;\n        if (this.skin != null) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin != null && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n\n        for (var i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        var attachment = slot.getAttachment();\n        if (attachment instanceof core.PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n        var constrained = constraint.bones;\n        var boneCount = constrained.length;\n\n        for (var i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (var i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n\n        for (var i = 0; i < boneCount; i++) constrained[i].sorted = true;\n      };\n\n      Skeleton.prototype.sortTransformConstraint = function (constraint) {\n        this.sortBone(constraint.target);\n        var constrained = constraint.bones;\n        var boneCount = constrained.length;\n\n        if (constraint.data.local) {\n          for (var i = 0; i < boneCount; i++) {\n            var child = constrained[i];\n            this.sortBone(child.parent);\n            if (!(this._updateCache.indexOf(child) > -1)) this.updateCacheReset.push(child);\n          }\n        } else {\n          for (var i = 0; i < boneCount; i++) {\n            this.sortBone(constrained[i]);\n          }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (var ii = 0; ii < boneCount; ii++) this.sortReset(constrained[ii].children);\n\n        for (var ii = 0; ii < boneCount; ii++) constrained[ii].sorted = true;\n      };\n\n      Skeleton.prototype.sortPathConstraintAttachment = function (skin, slotIndex, slotBone) {\n        var attachments = skin.attachments[slotIndex];\n        if (!attachments) return;\n\n        for (var key in attachments) {\n          this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n      };\n\n      Skeleton.prototype.sortPathConstraintAttachmentWith = function (attachment, slotBone) {\n        if (!(attachment instanceof core.PathAttachment)) return;\n        var pathBones = attachment.bones;\n        if (pathBones == null) this.sortBone(slotBone);else {\n          var bones = this.bones;\n          var i = 0;\n\n          while (i < pathBones.length) {\n            var boneCount = pathBones[i++];\n\n            for (var n = i + boneCount; i < n; i++) {\n              var boneIndex = pathBones[i];\n              this.sortBone(bones[boneIndex]);\n            }\n          }\n        }\n      };\n\n      Skeleton.prototype.sortBone = function (bone) {\n        if (bone.sorted) return;\n        var parent = bone.parent;\n        if (parent != null) this.sortBone(parent);\n        bone.sorted = true;\n\n        this._updateCache.push(bone);\n      };\n\n      Skeleton.prototype.sortReset = function (bones) {\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          if (bone.sorted) this.sortReset(bone.children);\n          bone.sorted = false;\n        }\n      };\n\n      Skeleton.prototype.updateWorldTransform = function () {\n        var updateCacheReset = this.updateCacheReset;\n\n        for (var i = 0, n = updateCacheReset.length; i < n; i++) {\n          var bone = updateCacheReset[i];\n          bone.ax = bone.x;\n          bone.ay = bone.y;\n          bone.arotation = bone.rotation;\n          bone.ascaleX = bone.scaleX;\n          bone.ascaleY = bone.scaleY;\n          bone.ashearX = bone.shearX;\n          bone.ashearY = bone.shearY;\n          bone.appliedValid = true;\n        }\n\n        var updateCache = this._updateCache;\n\n        for (var i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n      };\n\n      Skeleton.prototype.setToSetupPose = function () {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n      };\n\n      Skeleton.prototype.setBonesToSetupPose = function () {\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        var ikConstraints = this.ikConstraints;\n\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n          var constraint = ikConstraints[i];\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.mix = constraint.data.mix;\n        }\n\n        var transformConstraints = this.transformConstraints;\n\n        for (var i = 0, n = transformConstraints.length; i < n; i++) {\n          var constraint = transformConstraints[i];\n          var data = constraint.data;\n          constraint.rotateMix = data.rotateMix;\n          constraint.translateMix = data.translateMix;\n          constraint.scaleMix = data.scaleMix;\n          constraint.shearMix = data.shearMix;\n        }\n\n        var pathConstraints = this.pathConstraints;\n\n        for (var i = 0, n = pathConstraints.length; i < n; i++) {\n          var constraint = pathConstraints[i];\n          var data = constraint.data;\n          constraint.position = data.position;\n          constraint.spacing = data.spacing;\n          constraint.rotateMix = data.rotateMix;\n          constraint.translateMix = data.translateMix;\n        }\n      };\n\n      Skeleton.prototype.setSlotsToSetupPose = function () {\n        var slots = this.slots;\n        core.Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n\n        for (var i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n      };\n\n      Skeleton.prototype.getRootBone = function () {\n        if (this.bones.length == 0) return null;\n        return this.bones[0];\n      };\n\n      Skeleton.prototype.findBone = function (boneName) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n      };\n\n      Skeleton.prototype.findBoneIndex = function (boneName) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n      };\n\n      Skeleton.prototype.findSlot = function (slotName) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        var slots = this.slots;\n\n        for (var i = 0, n = slots.length; i < n; i++) {\n          var slot = slots[i];\n          if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n      };\n\n      Skeleton.prototype.findSlotIndex = function (slotName) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        var slots = this.slots;\n\n        for (var i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n      };\n\n      Skeleton.prototype.setSkinByName = function (skinName) {\n        var skin = this.data.findSkin(skinName);\n        if (skin == null) throw new Error(\"Skin not found: \" + skinName);\n        this.setSkin(skin);\n      };\n\n      Skeleton.prototype.setSkin = function (newSkin) {\n        if (newSkin != null) {\n          if (this.skin != null) newSkin.attachAll(this, this.skin);else {\n            var slots = this.slots;\n\n            for (var i = 0, n = slots.length; i < n; i++) {\n              var slot = slots[i];\n              var name_1 = slot.data.attachmentName;\n\n              if (name_1 != null) {\n                var attachment = newSkin.getAttachment(i, name_1);\n                if (attachment != null) slot.setAttachment(attachment);\n              }\n            }\n          }\n        }\n\n        this.skin = newSkin;\n      };\n\n      Skeleton.prototype.getAttachmentByName = function (slotName, attachmentName) {\n        return this.getAttachment(this.data.findSlotIndex(slotName), attachmentName);\n      };\n\n      Skeleton.prototype.getAttachment = function (slotIndex, attachmentName) {\n        if (attachmentName == null) throw new Error(\"attachmentName cannot be null.\");\n\n        if (this.skin != null) {\n          var attachment = this.skin.getAttachment(slotIndex, attachmentName);\n          if (attachment != null) return attachment;\n        }\n\n        if (this.data.defaultSkin != null) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n        return null;\n      };\n\n      Skeleton.prototype.setAttachment = function (slotName, attachmentName) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        var slots = this.slots;\n\n        for (var i = 0, n = slots.length; i < n; i++) {\n          var slot = slots[i];\n\n          if (slot.data.name == slotName) {\n            var attachment = null;\n\n            if (attachmentName != null) {\n              attachment = this.getAttachment(i, attachmentName);\n              if (attachment == null) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n            }\n\n            slot.setAttachment(attachment);\n            return;\n          }\n        }\n\n        throw new Error(\"Slot not found: \" + slotName);\n      };\n\n      Skeleton.prototype.findIkConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var ikConstraints = this.ikConstraints;\n\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n          var ikConstraint = ikConstraints[i];\n          if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n      };\n\n      Skeleton.prototype.findTransformConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var transformConstraints = this.transformConstraints;\n\n        for (var i = 0, n = transformConstraints.length; i < n; i++) {\n          var constraint = transformConstraints[i];\n          if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n      };\n\n      Skeleton.prototype.findPathConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var pathConstraints = this.pathConstraints;\n\n        for (var i = 0, n = pathConstraints.length; i < n; i++) {\n          var constraint = pathConstraints[i];\n          if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n      };\n\n      Skeleton.prototype.getBounds = function (offset, size, temp) {\n        if (offset == null) throw new Error(\"offset cannot be null.\");\n        if (size == null) throw new Error(\"size cannot be null.\");\n        var drawOrder = this.drawOrder;\n        var minX = Number.POSITIVE_INFINITY,\n            minY = Number.POSITIVE_INFINITY,\n            maxX = Number.NEGATIVE_INFINITY,\n            maxY = Number.NEGATIVE_INFINITY;\n\n        for (var i = 0, n = drawOrder.length; i < n; i++) {\n          var slot = drawOrder[i];\n          var verticesLength = 0;\n          var vertices = null;\n          var attachment = slot.getAttachment();\n\n          if (attachment instanceof core.RegionAttachment) {\n            verticesLength = 8;\n            vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n            attachment.computeWorldVertices(slot.bone, vertices, 0, 2);\n          } else if (attachment instanceof core.MeshAttachment) {\n            var mesh = attachment;\n            verticesLength = mesh.worldVerticesLength;\n            vertices = core.Utils.setArraySize(temp, verticesLength, 0);\n            mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n          }\n\n          if (vertices != null) {\n            for (var ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n              var x = vertices[ii],\n                  y = vertices[ii + 1];\n              minX = Math.min(minX, x);\n              minY = Math.min(minY, y);\n              maxX = Math.max(maxX, x);\n              maxY = Math.max(maxY, y);\n            }\n          }\n        }\n\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n      };\n\n      Skeleton.prototype.update = function (delta) {\n        this.time += delta;\n      };\n\n      Object.defineProperty(Skeleton.prototype, \"flipX\", {\n        get: function () {\n          return this.scaleX == -1;\n        },\n        set: function (value) {\n          if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n          }\n\n          this.scaleX = value ? 1.0 : -1.0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(Skeleton.prototype, \"flipY\", {\n        get: function () {\n          return this.scaleY == -1;\n        },\n        set: function (value) {\n          if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n          }\n\n          this.scaleY = value ? 1.0 : -1.0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Skeleton.deprecatedWarning1 = false;\n      return Skeleton;\n    }();\n\n    core.Skeleton = Skeleton;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SkeletonBounds = function () {\n      function SkeletonBounds() {\n        this.minX = 0;\n        this.minY = 0;\n        this.maxX = 0;\n        this.maxY = 0;\n        this.boundingBoxes = new Array();\n        this.polygons = new Array();\n        this.polygonPool = new core.Pool(function () {\n          return core.Utils.newFloatArray(16);\n        });\n      }\n\n      SkeletonBounds.prototype.update = function (skeleton, updateAabb) {\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        var boundingBoxes = this.boundingBoxes;\n        var polygons = this.polygons;\n        var polygonPool = this.polygonPool;\n        var slots = skeleton.slots;\n        var slotCount = slots.length;\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (var i = 0; i < slotCount; i++) {\n          var slot = slots[i];\n          var attachment = slot.getAttachment();\n\n          if (attachment instanceof core.BoundingBoxAttachment) {\n            var boundingBox = attachment;\n            boundingBoxes.push(boundingBox);\n            var polygon = polygonPool.obtain();\n\n            if (polygon.length != boundingBox.worldVerticesLength) {\n              polygon = core.Utils.newFloatArray(boundingBox.worldVerticesLength);\n            }\n\n            polygons.push(polygon);\n            boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n          }\n        }\n\n        if (updateAabb) {\n          this.aabbCompute();\n        } else {\n          this.minX = Number.POSITIVE_INFINITY;\n          this.minY = Number.POSITIVE_INFINITY;\n          this.maxX = Number.NEGATIVE_INFINITY;\n          this.maxY = Number.NEGATIVE_INFINITY;\n        }\n      };\n\n      SkeletonBounds.prototype.aabbCompute = function () {\n        var minX = Number.POSITIVE_INFINITY,\n            minY = Number.POSITIVE_INFINITY,\n            maxX = Number.NEGATIVE_INFINITY,\n            maxY = Number.NEGATIVE_INFINITY;\n        var polygons = this.polygons;\n\n        for (var i = 0, n = polygons.length; i < n; i++) {\n          var polygon = polygons[i];\n          var vertices = polygon;\n\n          for (var ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n            var x = vertices[ii];\n            var y = vertices[ii + 1];\n            minX = Math.min(minX, x);\n            minY = Math.min(minY, y);\n            maxX = Math.max(maxX, x);\n            maxY = Math.max(maxY, y);\n          }\n        }\n\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n      };\n\n      SkeletonBounds.prototype.aabbContainsPoint = function (x, y) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n      };\n\n      SkeletonBounds.prototype.aabbIntersectsSegment = function (x1, y1, x2, y2) {\n        var minX = this.minX;\n        var minY = this.minY;\n        var maxX = this.maxX;\n        var maxY = this.maxY;\n        if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n        var m = (y2 - y1) / (x2 - x1);\n        var y = m * (minX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        var x = (minY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n        return false;\n      };\n\n      SkeletonBounds.prototype.aabbIntersectsSkeleton = function (bounds) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n      };\n\n      SkeletonBounds.prototype.containsPoint = function (x, y) {\n        var polygons = this.polygons;\n\n        for (var i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n\n        return null;\n      };\n\n      SkeletonBounds.prototype.containsPointPolygon = function (polygon, x, y) {\n        var vertices = polygon;\n        var nn = polygon.length;\n        var prevIndex = nn - 2;\n        var inside = false;\n\n        for (var ii = 0; ii < nn; ii += 2) {\n          var vertexY = vertices[ii + 1];\n          var prevY = vertices[prevIndex + 1];\n\n          if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n            var vertexX = vertices[ii];\n            if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n          }\n\n          prevIndex = ii;\n        }\n\n        return inside;\n      };\n\n      SkeletonBounds.prototype.intersectsSegment = function (x1, y1, x2, y2) {\n        var polygons = this.polygons;\n\n        for (var i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n\n        return null;\n      };\n\n      SkeletonBounds.prototype.intersectsSegmentPolygon = function (polygon, x1, y1, x2, y2) {\n        var vertices = polygon;\n        var nn = polygon.length;\n        var width12 = x1 - x2,\n            height12 = y1 - y2;\n        var det1 = x1 * y2 - y1 * x2;\n        var x3 = vertices[nn - 2],\n            y3 = vertices[nn - 1];\n\n        for (var ii = 0; ii < nn; ii += 2) {\n          var x4 = vertices[ii],\n              y4 = vertices[ii + 1];\n          var det2 = x3 * y4 - y3 * x4;\n          var width34 = x3 - x4,\n              height34 = y3 - y4;\n          var det3 = width12 * height34 - height12 * width34;\n          var x = (det1 * width34 - width12 * det2) / det3;\n\n          if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n            var y = (det1 * height34 - height12 * det2) / det3;\n            if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n          }\n\n          x3 = x4;\n          y3 = y4;\n        }\n\n        return false;\n      };\n\n      SkeletonBounds.prototype.getPolygon = function (boundingBox) {\n        if (boundingBox == null) throw new Error(\"boundingBox cannot be null.\");\n        var index = this.boundingBoxes.indexOf(boundingBox);\n        return index == -1 ? null : this.polygons[index];\n      };\n\n      SkeletonBounds.prototype.getWidth = function () {\n        return this.maxX - this.minX;\n      };\n\n      SkeletonBounds.prototype.getHeight = function () {\n        return this.maxY - this.minY;\n      };\n\n      return SkeletonBounds;\n    }();\n\n    core.SkeletonBounds = SkeletonBounds;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SkeletonClipping = function () {\n      function SkeletonClipping() {\n        this.triangulator = new core.Triangulator();\n        this.clippingPolygon = new Array();\n        this.clipOutput = new Array();\n        this.clippedVertices = new Array();\n        this.clippedTriangles = new Array();\n        this.scratch = new Array();\n      }\n\n      SkeletonClipping.prototype.clipStart = function (slot, clip) {\n        if (this.clipAttachment != null) return 0;\n        this.clipAttachment = clip;\n        var n = clip.worldVerticesLength;\n        var vertices = core.Utils.setArraySize(this.clippingPolygon, n);\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n        var clippingPolygon = this.clippingPolygon;\n        SkeletonClipping.makeClockwise(clippingPolygon);\n        var clippingPolygons = this.clippingPolygons = this.triangulator.decompose(clippingPolygon, this.triangulator.triangulate(clippingPolygon));\n\n        for (var i = 0, n_1 = clippingPolygons.length; i < n_1; i++) {\n          var polygon = clippingPolygons[i];\n          SkeletonClipping.makeClockwise(polygon);\n          polygon.push(polygon[0]);\n          polygon.push(polygon[1]);\n        }\n\n        return clippingPolygons.length;\n      };\n\n      SkeletonClipping.prototype.clipEndWithSlot = function (slot) {\n        if (this.clipAttachment != null && this.clipAttachment.endSlot == slot.data) this.clipEnd();\n      };\n\n      SkeletonClipping.prototype.clipEnd = function () {\n        if (this.clipAttachment == null) return;\n        this.clipAttachment = null;\n        this.clippingPolygons = null;\n        this.clippedVertices.length = 0;\n        this.clippedTriangles.length = 0;\n        this.clippingPolygon.length = 0;\n      };\n\n      SkeletonClipping.prototype.isClipping = function () {\n        return this.clipAttachment != null;\n      };\n\n      SkeletonClipping.prototype.clipTriangles = function (vertices, verticesLength, triangles, trianglesLength, uvs, light, dark, twoColor) {\n        var clipOutput = this.clipOutput,\n            clippedVertices = this.clippedVertices;\n        var clippedTriangles = this.clippedTriangles;\n        var polygons = this.clippingPolygons;\n        var polygonsCount = this.clippingPolygons.length;\n        var vertexSize = twoColor ? 12 : 8;\n        var index = 0;\n        clippedVertices.length = 0;\n        clippedTriangles.length = 0;\n\n        outer: for (var i = 0; i < trianglesLength; i += 3) {\n          var vertexOffset = triangles[i] << 1;\n          var x1 = vertices[vertexOffset],\n              y1 = vertices[vertexOffset + 1];\n          var u1 = uvs[vertexOffset],\n              v1 = uvs[vertexOffset + 1];\n          vertexOffset = triangles[i + 1] << 1;\n          var x2 = vertices[vertexOffset],\n              y2 = vertices[vertexOffset + 1];\n          var u2 = uvs[vertexOffset],\n              v2 = uvs[vertexOffset + 1];\n          vertexOffset = triangles[i + 2] << 1;\n          var x3 = vertices[vertexOffset],\n              y3 = vertices[vertexOffset + 1];\n          var u3 = uvs[vertexOffset],\n              v3 = uvs[vertexOffset + 1];\n\n          for (var p = 0; p < polygonsCount; p++) {\n            var s = clippedVertices.length;\n\n            if (this.clip(x1, y1, x2, y2, x3, y3, polygons[p], clipOutput)) {\n              var clipOutputLength = clipOutput.length;\n              if (clipOutputLength == 0) continue;\n              var d0 = y2 - y3,\n                  d1 = x3 - x2,\n                  d2 = x1 - x3,\n                  d4 = y3 - y1;\n              var d = 1 / (d0 * d2 + d1 * (y1 - y3));\n              var clipOutputCount = clipOutputLength >> 1;\n              var clipOutputItems = this.clipOutput;\n              var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + clipOutputCount * vertexSize);\n\n              for (var ii = 0; ii < clipOutputLength; ii += 2) {\n                var x = clipOutputItems[ii],\n                    y = clipOutputItems[ii + 1];\n                clippedVerticesItems[s] = x;\n                clippedVerticesItems[s + 1] = y;\n                clippedVerticesItems[s + 2] = light.r;\n                clippedVerticesItems[s + 3] = light.g;\n                clippedVerticesItems[s + 4] = light.b;\n                clippedVerticesItems[s + 5] = light.a;\n                var c0 = x - x3,\n                    c1 = y - y3;\n                var a = (d0 * c0 + d1 * c1) * d;\n                var b = (d4 * c0 + d2 * c1) * d;\n                var c = 1 - a - b;\n                clippedVerticesItems[s + 6] = u1 * a + u2 * b + u3 * c;\n                clippedVerticesItems[s + 7] = v1 * a + v2 * b + v3 * c;\n\n                if (twoColor) {\n                  clippedVerticesItems[s + 8] = dark.r;\n                  clippedVerticesItems[s + 9] = dark.g;\n                  clippedVerticesItems[s + 10] = dark.b;\n                  clippedVerticesItems[s + 11] = dark.a;\n                }\n\n                s += vertexSize;\n              }\n\n              s = clippedTriangles.length;\n              var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3 * (clipOutputCount - 2));\n              clipOutputCount--;\n\n              for (var ii = 1; ii < clipOutputCount; ii++) {\n                clippedTrianglesItems[s] = index;\n                clippedTrianglesItems[s + 1] = index + ii;\n                clippedTrianglesItems[s + 2] = index + ii + 1;\n                s += 3;\n              }\n\n              index += clipOutputCount + 1;\n            } else {\n              var clippedVerticesItems = core.Utils.setArraySize(clippedVertices, s + 3 * vertexSize);\n              clippedVerticesItems[s] = x1;\n              clippedVerticesItems[s + 1] = y1;\n              clippedVerticesItems[s + 2] = light.r;\n              clippedVerticesItems[s + 3] = light.g;\n              clippedVerticesItems[s + 4] = light.b;\n              clippedVerticesItems[s + 5] = light.a;\n\n              if (!twoColor) {\n                clippedVerticesItems[s + 6] = u1;\n                clippedVerticesItems[s + 7] = v1;\n                clippedVerticesItems[s + 8] = x2;\n                clippedVerticesItems[s + 9] = y2;\n                clippedVerticesItems[s + 10] = light.r;\n                clippedVerticesItems[s + 11] = light.g;\n                clippedVerticesItems[s + 12] = light.b;\n                clippedVerticesItems[s + 13] = light.a;\n                clippedVerticesItems[s + 14] = u2;\n                clippedVerticesItems[s + 15] = v2;\n                clippedVerticesItems[s + 16] = x3;\n                clippedVerticesItems[s + 17] = y3;\n                clippedVerticesItems[s + 18] = light.r;\n                clippedVerticesItems[s + 19] = light.g;\n                clippedVerticesItems[s + 20] = light.b;\n                clippedVerticesItems[s + 21] = light.a;\n                clippedVerticesItems[s + 22] = u3;\n                clippedVerticesItems[s + 23] = v3;\n              } else {\n                clippedVerticesItems[s + 6] = u1;\n                clippedVerticesItems[s + 7] = v1;\n                clippedVerticesItems[s + 8] = dark.r;\n                clippedVerticesItems[s + 9] = dark.g;\n                clippedVerticesItems[s + 10] = dark.b;\n                clippedVerticesItems[s + 11] = dark.a;\n                clippedVerticesItems[s + 12] = x2;\n                clippedVerticesItems[s + 13] = y2;\n                clippedVerticesItems[s + 14] = light.r;\n                clippedVerticesItems[s + 15] = light.g;\n                clippedVerticesItems[s + 16] = light.b;\n                clippedVerticesItems[s + 17] = light.a;\n                clippedVerticesItems[s + 18] = u2;\n                clippedVerticesItems[s + 19] = v2;\n                clippedVerticesItems[s + 20] = dark.r;\n                clippedVerticesItems[s + 21] = dark.g;\n                clippedVerticesItems[s + 22] = dark.b;\n                clippedVerticesItems[s + 23] = dark.a;\n                clippedVerticesItems[s + 24] = x3;\n                clippedVerticesItems[s + 25] = y3;\n                clippedVerticesItems[s + 26] = light.r;\n                clippedVerticesItems[s + 27] = light.g;\n                clippedVerticesItems[s + 28] = light.b;\n                clippedVerticesItems[s + 29] = light.a;\n                clippedVerticesItems[s + 30] = u3;\n                clippedVerticesItems[s + 31] = v3;\n                clippedVerticesItems[s + 32] = dark.r;\n                clippedVerticesItems[s + 33] = dark.g;\n                clippedVerticesItems[s + 34] = dark.b;\n                clippedVerticesItems[s + 35] = dark.a;\n              }\n\n              s = clippedTriangles.length;\n              var clippedTrianglesItems = core.Utils.setArraySize(clippedTriangles, s + 3);\n              clippedTrianglesItems[s] = index;\n              clippedTrianglesItems[s + 1] = index + 1;\n              clippedTrianglesItems[s + 2] = index + 2;\n              index += 3;\n              continue outer;\n            }\n          }\n        }\n      };\n\n      SkeletonClipping.prototype.clip = function (x1, y1, x2, y2, x3, y3, clippingArea, output) {\n        var originalOutput = output;\n        var clipped = false;\n        var input = null;\n\n        if (clippingArea.length % 4 >= 2) {\n          input = output;\n          output = this.scratch;\n        } else input = this.scratch;\n\n        input.length = 0;\n        input.push(x1);\n        input.push(y1);\n        input.push(x2);\n        input.push(y2);\n        input.push(x3);\n        input.push(y3);\n        input.push(x1);\n        input.push(y1);\n        output.length = 0;\n        var clippingVertices = clippingArea;\n        var clippingVerticesLast = clippingArea.length - 4;\n\n        for (var i = 0;; i += 2) {\n          var edgeX = clippingVertices[i],\n              edgeY = clippingVertices[i + 1];\n          var edgeX2 = clippingVertices[i + 2],\n              edgeY2 = clippingVertices[i + 3];\n          var deltaX = edgeX - edgeX2,\n              deltaY = edgeY - edgeY2;\n          var inputVertices = input;\n          var inputVerticesLength = input.length - 2,\n              outputStart = output.length;\n\n          for (var ii = 0; ii < inputVerticesLength; ii += 2) {\n            var inputX = inputVertices[ii],\n                inputY = inputVertices[ii + 1];\n            var inputX2 = inputVertices[ii + 2],\n                inputY2 = inputVertices[ii + 3];\n            var side2 = deltaX * (inputY2 - edgeY2) - deltaY * (inputX2 - edgeX2) > 0;\n\n            if (deltaX * (inputY - edgeY2) - deltaY * (inputX - edgeX2) > 0) {\n              if (side2) {\n                output.push(inputX2);\n                output.push(inputY2);\n                continue;\n              }\n\n              var c0 = inputY2 - inputY,\n                  c2 = inputX2 - inputX;\n              var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n              output.push(edgeX + (edgeX2 - edgeX) * ua);\n              output.push(edgeY + (edgeY2 - edgeY) * ua);\n            } else if (side2) {\n              var c0 = inputY2 - inputY,\n                  c2 = inputX2 - inputX;\n              var ua = (c2 * (edgeY - inputY) - c0 * (edgeX - inputX)) / (c0 * (edgeX2 - edgeX) - c2 * (edgeY2 - edgeY));\n              output.push(edgeX + (edgeX2 - edgeX) * ua);\n              output.push(edgeY + (edgeY2 - edgeY) * ua);\n              output.push(inputX2);\n              output.push(inputY2);\n            }\n\n            clipped = true;\n          }\n\n          if (outputStart == output.length) {\n            originalOutput.length = 0;\n            return true;\n          }\n\n          output.push(output[0]);\n          output.push(output[1]);\n          if (i == clippingVerticesLast) break;\n          var temp = output;\n          output = input;\n          output.length = 0;\n          input = temp;\n        }\n\n        if (originalOutput != output) {\n          originalOutput.length = 0;\n\n          for (var i = 0, n = output.length - 2; i < n; i++) originalOutput[i] = output[i];\n        } else originalOutput.length = originalOutput.length - 2;\n\n        return clipped;\n      };\n\n      SkeletonClipping.makeClockwise = function (polygon) {\n        var vertices = polygon;\n        var verticeslength = polygon.length;\n        var area = vertices[verticeslength - 2] * vertices[1] - vertices[0] * vertices[verticeslength - 1],\n            p1x = 0,\n            p1y = 0,\n            p2x = 0,\n            p2y = 0;\n\n        for (var i = 0, n = verticeslength - 3; i < n; i += 2) {\n          p1x = vertices[i];\n          p1y = vertices[i + 1];\n          p2x = vertices[i + 2];\n          p2y = vertices[i + 3];\n          area += p1x * p2y - p2x * p1y;\n        }\n\n        if (area < 0) return;\n\n        for (var i = 0, lastX = verticeslength - 2, n = verticeslength >> 1; i < n; i += 2) {\n          var x = vertices[i],\n              y = vertices[i + 1];\n          var other = lastX - i;\n          vertices[i] = vertices[other];\n          vertices[i + 1] = vertices[other + 1];\n          vertices[other] = x;\n          vertices[other + 1] = y;\n        }\n      };\n\n      return SkeletonClipping;\n    }();\n\n    core.SkeletonClipping = SkeletonClipping;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SkeletonData = function () {\n      function SkeletonData() {\n        this.bones = new Array();\n        this.slots = new Array();\n        this.skins = new Array();\n        this.events = new Array();\n        this.animations = new Array();\n        this.ikConstraints = new Array();\n        this.transformConstraints = new Array();\n        this.pathConstraints = new Array();\n        this.fps = 0;\n      }\n\n      SkeletonData.prototype.findBone = function (boneName) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          if (bone.name == boneName) return bone;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findBoneIndex = function (boneName) {\n        if (boneName == null) throw new Error(\"boneName cannot be null.\");\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) if (bones[i].name == boneName) return i;\n\n        return -1;\n      };\n\n      SkeletonData.prototype.findSlot = function (slotName) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        var slots = this.slots;\n\n        for (var i = 0, n = slots.length; i < n; i++) {\n          var slot = slots[i];\n          if (slot.name == slotName) return slot;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findSlotIndex = function (slotName) {\n        if (slotName == null) throw new Error(\"slotName cannot be null.\");\n        var slots = this.slots;\n\n        for (var i = 0, n = slots.length; i < n; i++) if (slots[i].name == slotName) return i;\n\n        return -1;\n      };\n\n      SkeletonData.prototype.findSkin = function (skinName) {\n        if (skinName == null) throw new Error(\"skinName cannot be null.\");\n        var skins = this.skins;\n\n        for (var i = 0, n = skins.length; i < n; i++) {\n          var skin = skins[i];\n          if (skin.name == skinName) return skin;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findEvent = function (eventDataName) {\n        if (eventDataName == null) throw new Error(\"eventDataName cannot be null.\");\n        var events = this.events;\n\n        for (var i = 0, n = events.length; i < n; i++) {\n          var event_4 = events[i];\n          if (event_4.name == eventDataName) return event_4;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findAnimation = function (animationName) {\n        if (animationName == null) throw new Error(\"animationName cannot be null.\");\n        var animations = this.animations;\n\n        for (var i = 0, n = animations.length; i < n; i++) {\n          var animation = animations[i];\n          if (animation.name == animationName) return animation;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findIkConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var ikConstraints = this.ikConstraints;\n\n        for (var i = 0, n = ikConstraints.length; i < n; i++) {\n          var constraint = ikConstraints[i];\n          if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findTransformConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var transformConstraints = this.transformConstraints;\n\n        for (var i = 0, n = transformConstraints.length; i < n; i++) {\n          var constraint = transformConstraints[i];\n          if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findPathConstraint = function (constraintName) {\n        if (constraintName == null) throw new Error(\"constraintName cannot be null.\");\n        var pathConstraints = this.pathConstraints;\n\n        for (var i = 0, n = pathConstraints.length; i < n; i++) {\n          var constraint = pathConstraints[i];\n          if (constraint.name == constraintName) return constraint;\n        }\n\n        return null;\n      };\n\n      SkeletonData.prototype.findPathConstraintIndex = function (pathConstraintName) {\n        if (pathConstraintName == null) throw new Error(\"pathConstraintName cannot be null.\");\n        var pathConstraints = this.pathConstraints;\n\n        for (var i = 0, n = pathConstraints.length; i < n; i++) if (pathConstraints[i].name == pathConstraintName) return i;\n\n        return -1;\n      };\n\n      return SkeletonData;\n    }();\n\n    core.SkeletonData = SkeletonData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SkeletonJson = function () {\n      function SkeletonJson(attachmentLoader) {\n        this.scale = 1;\n        this.linkedMeshes = new Array();\n        this.attachmentLoader = attachmentLoader;\n      }\n\n      SkeletonJson.prototype.readSkeletonData = function (json) {\n        var scale = this.scale;\n        var skeletonData = new core.SkeletonData();\n        var root = typeof json === \"string\" ? JSON.parse(json) : json;\n        var skeletonMap = root.skeleton;\n\n        if (skeletonMap != null) {\n          skeletonData.hash = skeletonMap.hash;\n          skeletonData.version = skeletonMap.spine;\n          skeletonData.width = skeletonMap.width;\n          skeletonData.height = skeletonMap.height;\n          skeletonData.fps = skeletonMap.fps;\n          skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        if (root.bones) {\n          for (var i = 0; i < root.bones.length; i++) {\n            var boneMap = root.bones[i];\n            var parent_2 = null;\n            var parentName = this.getValue(boneMap, \"parent\", null);\n\n            if (parentName != null) {\n              parent_2 = skeletonData.findBone(parentName);\n              if (parent_2 == null) throw new Error(\"Parent bone not found: \" + parentName);\n            }\n\n            var data = new core.BoneData(skeletonData.bones.length, boneMap.name, parent_2);\n            data.length = this.getValue(boneMap, \"length\", 0) * scale;\n            data.x = this.getValue(boneMap, \"x\", 0) * scale;\n            data.y = this.getValue(boneMap, \"y\", 0) * scale;\n            data.rotation = this.getValue(boneMap, \"rotation\", 0);\n            data.scaleX = this.getValue(boneMap, \"scaleX\", 1);\n            data.scaleY = this.getValue(boneMap, \"scaleY\", 1);\n            data.shearX = this.getValue(boneMap, \"shearX\", 0);\n            data.shearY = this.getValue(boneMap, \"shearY\", 0);\n            data.transformMode = SkeletonJson.transformModeFromString(this.getValue(boneMap, \"transform\", \"normal\"));\n            skeletonData.bones.push(data);\n          }\n        }\n\n        if (root.slots) {\n          for (var i = 0; i < root.slots.length; i++) {\n            var slotMap = root.slots[i];\n            var slotName = slotMap.name;\n            var boneName = slotMap.bone;\n            var boneData = skeletonData.findBone(boneName);\n            if (boneData == null) throw new Error(\"Slot bone not found: \" + boneName);\n            var data = new core.SlotData(skeletonData.slots.length, slotName, boneData);\n            var color = this.getValue(slotMap, \"color\", null);\n            if (color != null) data.color.setFromString(color);\n            var dark = this.getValue(slotMap, \"dark\", null);\n\n            if (dark != null) {\n              data.darkColor = new core.Color(1, 1, 1, 1);\n              data.darkColor.setFromString(dark);\n            }\n\n            data.attachmentName = this.getValue(slotMap, \"attachment\", null);\n            data.blendMode = SkeletonJson.blendModeFromString(this.getValue(slotMap, \"blend\", \"normal\"));\n            skeletonData.slots.push(data);\n          }\n        }\n\n        if (root.ik) {\n          for (var i = 0; i < root.ik.length; i++) {\n            var constraintMap = root.ik[i];\n            var data = new core.IkConstraintData(constraintMap.name);\n            data.order = this.getValue(constraintMap, \"order\", 0);\n\n            for (var j = 0; j < constraintMap.bones.length; j++) {\n              var boneName = constraintMap.bones[j];\n              var bone = skeletonData.findBone(boneName);\n              if (bone == null) throw new Error(\"IK bone not found: \" + boneName);\n              data.bones.push(bone);\n            }\n\n            var targetName = constraintMap.target;\n            data.target = skeletonData.findBone(targetName);\n            if (data.target == null) throw new Error(\"IK target bone not found: \" + targetName);\n            data.bendDirection = this.getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n            data.mix = this.getValue(constraintMap, \"mix\", 1);\n            skeletonData.ikConstraints.push(data);\n          }\n        }\n\n        if (root.transform) {\n          for (var i = 0; i < root.transform.length; i++) {\n            var constraintMap = root.transform[i];\n            var data = new core.TransformConstraintData(constraintMap.name);\n            data.order = this.getValue(constraintMap, \"order\", 0);\n\n            for (var j = 0; j < constraintMap.bones.length; j++) {\n              var boneName = constraintMap.bones[j];\n              var bone = skeletonData.findBone(boneName);\n              if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n              data.bones.push(bone);\n            }\n\n            var targetName = constraintMap.target;\n            data.target = skeletonData.findBone(targetName);\n            if (data.target == null) throw new Error(\"Transform constraint target bone not found: \" + targetName);\n            data.local = this.getValue(constraintMap, \"local\", false);\n            data.relative = this.getValue(constraintMap, \"relative\", false);\n            data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n            data.offsetX = this.getValue(constraintMap, \"x\", 0) * scale;\n            data.offsetY = this.getValue(constraintMap, \"y\", 0) * scale;\n            data.offsetScaleX = this.getValue(constraintMap, \"scaleX\", 0);\n            data.offsetScaleY = this.getValue(constraintMap, \"scaleY\", 0);\n            data.offsetShearY = this.getValue(constraintMap, \"shearY\", 0);\n            data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n            data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n            data.scaleMix = this.getValue(constraintMap, \"scaleMix\", 1);\n            data.shearMix = this.getValue(constraintMap, \"shearMix\", 1);\n            skeletonData.transformConstraints.push(data);\n          }\n        }\n\n        if (root.path) {\n          for (var i = 0; i < root.path.length; i++) {\n            var constraintMap = root.path[i];\n            var data = new core.PathConstraintData(constraintMap.name);\n            data.order = this.getValue(constraintMap, \"order\", 0);\n\n            for (var j = 0; j < constraintMap.bones.length; j++) {\n              var boneName = constraintMap.bones[j];\n              var bone = skeletonData.findBone(boneName);\n              if (bone == null) throw new Error(\"Transform constraint bone not found: \" + boneName);\n              data.bones.push(bone);\n            }\n\n            var targetName = constraintMap.target;\n            data.target = skeletonData.findSlot(targetName);\n            if (data.target == null) throw new Error(\"Path target slot not found: \" + targetName);\n            data.positionMode = SkeletonJson.positionModeFromString(this.getValue(constraintMap, \"positionMode\", \"percent\"));\n            data.spacingMode = SkeletonJson.spacingModeFromString(this.getValue(constraintMap, \"spacingMode\", \"length\"));\n            data.rotateMode = SkeletonJson.rotateModeFromString(this.getValue(constraintMap, \"rotateMode\", \"tangent\"));\n            data.offsetRotation = this.getValue(constraintMap, \"rotation\", 0);\n            data.position = this.getValue(constraintMap, \"position\", 0);\n            if (data.positionMode == core.PositionMode.Fixed) data.position *= scale;\n            data.spacing = this.getValue(constraintMap, \"spacing\", 0);\n            if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) data.spacing *= scale;\n            data.rotateMix = this.getValue(constraintMap, \"rotateMix\", 1);\n            data.translateMix = this.getValue(constraintMap, \"translateMix\", 1);\n            skeletonData.pathConstraints.push(data);\n          }\n        }\n\n        if (root.skins) {\n          for (var skinName in root.skins) {\n            var skinMap = root.skins[skinName];\n            var skin = new core.Skin(skinName);\n\n            for (var slotName in skinMap) {\n              var slotIndex = skeletonData.findSlotIndex(slotName);\n              if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n              var slotMap = skinMap[slotName];\n\n              for (var entryName in slotMap) {\n                var attachment = this.readAttachment(slotMap[entryName], skin, slotIndex, entryName, skeletonData);\n                if (attachment != null) skin.addAttachment(slotIndex, entryName, attachment);\n              }\n            }\n\n            skeletonData.skins.push(skin);\n            if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n          }\n        }\n\n        for (var i = 0, n = this.linkedMeshes.length; i < n; i++) {\n          var linkedMesh = this.linkedMeshes[i];\n          var skin = linkedMesh.skin == null ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n          if (skin == null) throw new Error(\"Skin not found: \" + linkedMesh.skin);\n          var parent_3 = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n          if (parent_3 == null) throw new Error(\"Parent mesh not found: \" + linkedMesh.parent);\n          linkedMesh.mesh.setParentMesh(parent_3);\n        }\n\n        this.linkedMeshes.length = 0;\n\n        if (root.events) {\n          for (var eventName in root.events) {\n            var eventMap = root.events[eventName];\n            var data = new core.EventData(eventName);\n            data.intValue = this.getValue(eventMap, \"int\", 0);\n            data.floatValue = this.getValue(eventMap, \"float\", 0);\n            data.stringValue = this.getValue(eventMap, \"string\", \"\");\n            data.audioPath = this.getValue(eventMap, \"audio\", null);\n\n            if (data.audioPath != null) {\n              data.volume = this.getValue(eventMap, \"volume\", 1);\n              data.balance = this.getValue(eventMap, \"balance\", 0);\n            }\n\n            skeletonData.events.push(data);\n          }\n        }\n\n        if (root.animations) {\n          for (var animationName in root.animations) {\n            var animationMap = root.animations[animationName];\n            this.readAnimation(animationMap, animationName, skeletonData);\n          }\n        }\n\n        return skeletonData;\n      };\n\n      SkeletonJson.prototype.readAttachment = function (map, skin, slotIndex, name, skeletonData) {\n        var scale = this.scale;\n        name = this.getValue(map, \"name\", name);\n        var type = this.getValue(map, \"type\", \"region\");\n\n        switch (type) {\n          case \"region\":\n            {\n              var path = this.getValue(map, \"path\", name);\n              var region = this.attachmentLoader.newRegionAttachment(skin, name, path);\n              if (region == null) return null;\n              region.path = path;\n              region.x = this.getValue(map, \"x\", 0) * scale;\n              region.y = this.getValue(map, \"y\", 0) * scale;\n              region.scaleX = this.getValue(map, \"scaleX\", 1);\n              region.scaleY = this.getValue(map, \"scaleY\", 1);\n              region.rotation = this.getValue(map, \"rotation\", 0);\n              region.width = map.width * scale;\n              region.height = map.height * scale;\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) region.color.setFromString(color);\n              return region;\n            }\n\n          case \"boundingbox\":\n            {\n              var box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n              if (box == null) return null;\n              this.readVertices(map, box, map.vertexCount << 1);\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) box.color.setFromString(color);\n              return box;\n            }\n\n          case \"mesh\":\n          case \"linkedmesh\":\n            {\n              var path = this.getValue(map, \"path\", name);\n              var mesh = this.attachmentLoader.newMeshAttachment(skin, name, path);\n              if (mesh == null) return null;\n              mesh.path = path;\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) mesh.color.setFromString(color);\n              var parent_4 = this.getValue(map, \"parent\", null);\n\n              if (parent_4 != null) {\n                mesh.inheritDeform = this.getValue(map, \"deform\", true);\n                this.linkedMeshes.push(new LinkedMesh(mesh, this.getValue(map, \"skin\", null), slotIndex, parent_4));\n                return mesh;\n              }\n\n              var uvs = map.uvs;\n              this.readVertices(map, mesh, uvs.length);\n              mesh.triangles = map.triangles;\n              mesh.regionUVs = new Float32Array(uvs);\n              mesh.hullLength = this.getValue(map, \"hull\", 0) * 2;\n              return mesh;\n            }\n\n          case \"path\":\n            {\n              var path = this.attachmentLoader.newPathAttachment(skin, name);\n              if (path == null) return null;\n              path.closed = this.getValue(map, \"closed\", false);\n              path.constantSpeed = this.getValue(map, \"constantSpeed\", true);\n              var vertexCount = map.vertexCount;\n              this.readVertices(map, path, vertexCount << 1);\n              var lengths = core.Utils.newArray(vertexCount / 3, 0);\n\n              for (var i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n\n              path.lengths = lengths;\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) path.color.setFromString(color);\n              return path;\n            }\n\n          case \"point\":\n            {\n              var point = this.attachmentLoader.newPointAttachment(skin, name);\n              if (point == null) return null;\n              point.x = this.getValue(map, \"x\", 0) * scale;\n              point.y = this.getValue(map, \"y\", 0) * scale;\n              point.rotation = this.getValue(map, \"rotation\", 0);\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) point.color.setFromString(color);\n              return point;\n            }\n\n          case \"clipping\":\n            {\n              var clip = this.attachmentLoader.newClippingAttachment(skin, name);\n              if (clip == null) return null;\n              var end = this.getValue(map, \"end\", null);\n\n              if (end != null) {\n                var slot = skeletonData.findSlot(end);\n                if (slot == null) throw new Error(\"Clipping end slot not found: \" + end);\n                clip.endSlot = slot;\n              }\n\n              var vertexCount = map.vertexCount;\n              this.readVertices(map, clip, vertexCount << 1);\n              var color = this.getValue(map, \"color\", null);\n              if (color != null) clip.color.setFromString(color);\n              return clip;\n            }\n        }\n\n        return null;\n      };\n\n      SkeletonJson.prototype.readVertices = function (map, attachment, verticesLength) {\n        var scale = this.scale;\n        attachment.worldVerticesLength = verticesLength;\n        var vertices = map.vertices;\n\n        if (verticesLength == vertices.length) {\n          var scaledVertices = core.Utils.toFloatArray(vertices);\n\n          if (scale != 1) {\n            for (var i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n          }\n\n          attachment.vertices = scaledVertices;\n          return;\n        }\n\n        var weights = new Array();\n        var bones = new Array();\n\n        for (var i = 0, n = vertices.length; i < n;) {\n          var boneCount = vertices[i++];\n          bones.push(boneCount);\n\n          for (var nn = i + boneCount * 4; i < nn; i += 4) {\n            bones.push(vertices[i]);\n            weights.push(vertices[i + 1] * scale);\n            weights.push(vertices[i + 2] * scale);\n            weights.push(vertices[i + 3]);\n          }\n        }\n\n        attachment.bones = bones;\n        attachment.vertices = core.Utils.toFloatArray(weights);\n      };\n\n      SkeletonJson.prototype.readAnimation = function (map, name, skeletonData) {\n        var scale = this.scale;\n        var timelines = new Array();\n        var duration = 0;\n\n        if (map.slots) {\n          for (var slotName in map.slots) {\n            var slotMap = map.slots[slotName];\n            var slotIndex = skeletonData.findSlotIndex(slotName);\n            if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotName);\n\n            for (var timelineName in slotMap) {\n              var timelineMap = slotMap[timelineName];\n\n              if (timelineName == \"attachment\") {\n                var timeline = new core.AttachmentTimeline(timelineMap.length);\n                timeline.slotIndex = slotIndex;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  timeline.setFrame(frameIndex++, valueMap.time, valueMap.name);\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n              } else if (timelineName == \"color\") {\n                var timeline = new core.ColorTimeline(timelineMap.length);\n                timeline.slotIndex = slotIndex;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  var color = new core.Color();\n                  color.setFromString(valueMap.color || \"ffffffff\");\n                  timeline.setFrame(frameIndex, valueMap.time, color.r, color.g, color.b, color.a);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.ColorTimeline.ENTRIES]);\n              } else if (timelineName == \"twoColor\") {\n                var timeline = new core.TwoColorTimeline(timelineMap.length);\n                timeline.slotIndex = slotIndex;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  var light = new core.Color();\n                  var dark = new core.Color();\n                  light.setFromString(valueMap.light);\n                  dark.setFromString(valueMap.dark);\n                  timeline.setFrame(frameIndex, valueMap.time, light.r, light.g, light.b, light.a, dark.r, dark.g, dark.b);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TwoColorTimeline.ENTRIES]);\n              } else throw new Error(\"Invalid timeline type for a slot: \" + timelineName + \" (\" + slotName + \")\");\n            }\n          }\n        }\n\n        if (map.bones) {\n          for (var boneName in map.bones) {\n            var boneMap = map.bones[boneName];\n            var boneIndex = skeletonData.findBoneIndex(boneName);\n            if (boneIndex == -1) throw new Error(\"Bone not found: \" + boneName);\n\n            for (var timelineName in boneMap) {\n              var timelineMap = boneMap[timelineName];\n\n              if (timelineName === \"rotate\") {\n                var timeline = new core.RotateTimeline(timelineMap.length);\n                timeline.boneIndex = boneIndex;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  timeline.setFrame(frameIndex, valueMap.time, valueMap.angle);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.RotateTimeline.ENTRIES]);\n              } else if (timelineName === \"translate\" || timelineName === \"scale\" || timelineName === \"shear\") {\n                var timeline = null;\n                var timelineScale = 1;\n                if (timelineName === \"scale\") timeline = new core.ScaleTimeline(timelineMap.length);else if (timelineName === \"shear\") timeline = new core.ShearTimeline(timelineMap.length);else {\n                  timeline = new core.TranslateTimeline(timelineMap.length);\n                  timelineScale = scale;\n                }\n                timeline.boneIndex = boneIndex;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  var x = this.getValue(valueMap, \"x\", 0),\n                      y = this.getValue(valueMap, \"y\", 0);\n                  timeline.setFrame(frameIndex, valueMap.time, x * timelineScale, y * timelineScale);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TranslateTimeline.ENTRIES]);\n              } else throw new Error(\"Invalid timeline type for a bone: \" + timelineName + \" (\" + boneName + \")\");\n            }\n          }\n        }\n\n        if (map.ik) {\n          for (var constraintName in map.ik) {\n            var constraintMap = map.ik[constraintName];\n            var constraint = skeletonData.findIkConstraint(constraintName);\n            var timeline = new core.IkConstraintTimeline(constraintMap.length);\n            timeline.ikConstraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n            var frameIndex = 0;\n\n            for (var i = 0; i < constraintMap.length; i++) {\n              var valueMap = constraintMap[i];\n              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"mix\", 1), this.getValue(valueMap, \"bendPositive\", true) ? 1 : -1, this.getValue(valueMap, \"compress\", false), this.getValue(valueMap, \"stretch\", false));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.IkConstraintTimeline.ENTRIES]);\n          }\n        }\n\n        if (map.transform) {\n          for (var constraintName in map.transform) {\n            var constraintMap = map.transform[constraintName];\n            var constraint = skeletonData.findTransformConstraint(constraintName);\n            var timeline = new core.TransformConstraintTimeline(constraintMap.length);\n            timeline.transformConstraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n            var frameIndex = 0;\n\n            for (var i = 0; i < constraintMap.length; i++) {\n              var valueMap = constraintMap[i];\n              timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1), this.getValue(valueMap, \"scaleMix\", 1), this.getValue(valueMap, \"shearMix\", 1));\n              this.readCurve(valueMap, timeline, frameIndex);\n              frameIndex++;\n            }\n\n            timelines.push(timeline);\n            duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.TransformConstraintTimeline.ENTRIES]);\n          }\n        }\n\n        if (map.paths) {\n          for (var constraintName in map.paths) {\n            var constraintMap = map.paths[constraintName];\n            var index = skeletonData.findPathConstraintIndex(constraintName);\n            if (index == -1) throw new Error(\"Path constraint not found: \" + constraintName);\n            var data = skeletonData.pathConstraints[index];\n\n            for (var timelineName in constraintMap) {\n              var timelineMap = constraintMap[timelineName];\n\n              if (timelineName === \"position\" || timelineName === \"spacing\") {\n                var timeline = null;\n                var timelineScale = 1;\n\n                if (timelineName === \"spacing\") {\n                  timeline = new core.PathConstraintSpacingTimeline(timelineMap.length);\n                  if (data.spacingMode == core.SpacingMode.Length || data.spacingMode == core.SpacingMode.Fixed) timelineScale = scale;\n                } else {\n                  timeline = new core.PathConstraintPositionTimeline(timelineMap.length);\n                  if (data.positionMode == core.PositionMode.Fixed) timelineScale = scale;\n                }\n\n                timeline.pathConstraintIndex = index;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, timelineName, 0) * timelineScale);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintPositionTimeline.ENTRIES]);\n              } else if (timelineName === \"mix\") {\n                var timeline = new core.PathConstraintMixTimeline(timelineMap.length);\n                timeline.pathConstraintIndex = index;\n                var frameIndex = 0;\n\n                for (var i = 0; i < timelineMap.length; i++) {\n                  var valueMap = timelineMap[i];\n                  timeline.setFrame(frameIndex, valueMap.time, this.getValue(valueMap, \"rotateMix\", 1), this.getValue(valueMap, \"translateMix\", 1));\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[(timeline.getFrameCount() - 1) * core.PathConstraintMixTimeline.ENTRIES]);\n              }\n            }\n          }\n        }\n\n        if (map.deform) {\n          for (var deformName in map.deform) {\n            var deformMap = map.deform[deformName];\n            var skin = skeletonData.findSkin(deformName);\n            if (skin == null) throw new Error(\"Skin not found: \" + deformName);\n\n            for (var slotName in deformMap) {\n              var slotMap = deformMap[slotName];\n              var slotIndex = skeletonData.findSlotIndex(slotName);\n              if (slotIndex == -1) throw new Error(\"Slot not found: \" + slotMap.name);\n\n              for (var timelineName in slotMap) {\n                var timelineMap = slotMap[timelineName];\n                var attachment = skin.getAttachment(slotIndex, timelineName);\n                if (attachment == null) throw new Error(\"Deform attachment not found: \" + timelineMap.name);\n                var weighted = attachment.bones != null;\n                var vertices = attachment.vertices;\n                var deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                var timeline = new core.DeformTimeline(timelineMap.length);\n                timeline.slotIndex = slotIndex;\n                timeline.attachment = attachment;\n                var frameIndex = 0;\n\n                for (var j = 0; j < timelineMap.length; j++) {\n                  var valueMap = timelineMap[j];\n                  var deform = void 0;\n                  var verticesValue = this.getValue(valueMap, \"vertices\", null);\n                  if (verticesValue == null) deform = weighted ? core.Utils.newFloatArray(deformLength) : vertices;else {\n                    deform = core.Utils.newFloatArray(deformLength);\n                    var start = this.getValue(valueMap, \"offset\", 0);\n                    core.Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n\n                    if (scale != 1) {\n                      for (var i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                    }\n\n                    if (!weighted) {\n                      for (var i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                    }\n                  }\n                  timeline.setFrame(frameIndex, valueMap.time, deform);\n                  this.readCurve(valueMap, timeline, frameIndex);\n                  frameIndex++;\n                }\n\n                timelines.push(timeline);\n                duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n              }\n            }\n          }\n        }\n\n        var drawOrderNode = map.drawOrder;\n        if (drawOrderNode == null) drawOrderNode = map.draworder;\n\n        if (drawOrderNode != null) {\n          var timeline = new core.DrawOrderTimeline(drawOrderNode.length);\n          var slotCount = skeletonData.slots.length;\n          var frameIndex = 0;\n\n          for (var j = 0; j < drawOrderNode.length; j++) {\n            var drawOrderMap = drawOrderNode[j];\n            var drawOrder = null;\n            var offsets = this.getValue(drawOrderMap, \"offsets\", null);\n\n            if (offsets != null) {\n              drawOrder = core.Utils.newArray(slotCount, -1);\n              var unchanged = core.Utils.newArray(slotCount - offsets.length, 0);\n              var originalIndex = 0,\n                  unchangedIndex = 0;\n\n              for (var i = 0; i < offsets.length; i++) {\n                var offsetMap = offsets[i];\n                var slotIndex = skeletonData.findSlotIndex(offsetMap.slot);\n                if (slotIndex == -1) throw new Error(\"Slot not found: \" + offsetMap.slot);\n\n                while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n\n                drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n              }\n\n              while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n\n              for (var i = slotCount - 1; i >= 0; i--) if (drawOrder[i] == -1) drawOrder[i] = unchanged[--unchangedIndex];\n            }\n\n            timeline.setFrame(frameIndex++, drawOrderMap.time, drawOrder);\n          }\n\n          timelines.push(timeline);\n          duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (map.events) {\n          var timeline = new core.EventTimeline(map.events.length);\n          var frameIndex = 0;\n\n          for (var i = 0; i < map.events.length; i++) {\n            var eventMap = map.events[i];\n            var eventData = skeletonData.findEvent(eventMap.name);\n            if (eventData == null) throw new Error(\"Event not found: \" + eventMap.name);\n            var event_5 = new core.Event(core.Utils.toSinglePrecision(eventMap.time), eventData);\n            event_5.intValue = this.getValue(eventMap, \"int\", eventData.intValue);\n            event_5.floatValue = this.getValue(eventMap, \"float\", eventData.floatValue);\n            event_5.stringValue = this.getValue(eventMap, \"string\", eventData.stringValue);\n\n            if (event_5.data.audioPath != null) {\n              event_5.volume = this.getValue(eventMap, \"volume\", 1);\n              event_5.balance = this.getValue(eventMap, \"balance\", 0);\n            }\n\n            timeline.setFrame(frameIndex++, event_5);\n          }\n\n          timelines.push(timeline);\n          duration = Math.max(duration, timeline.frames[timeline.getFrameCount() - 1]);\n        }\n\n        if (isNaN(duration)) {\n          throw new Error(\"Error while parsing animation, duration is NaN\");\n        }\n\n        skeletonData.animations.push(new core.Animation(name, timelines, duration));\n      };\n\n      SkeletonJson.prototype.readCurve = function (map, timeline, frameIndex) {\n        if (!map.curve) return;\n        if (map.curve === \"stepped\") timeline.setStepped(frameIndex);else if (Object.prototype.toString.call(map.curve) === '[object Array]') {\n          var curve = map.curve;\n          timeline.setCurve(frameIndex, curve[0], curve[1], curve[2], curve[3]);\n        }\n      };\n\n      SkeletonJson.prototype.getValue = function (map, prop, defaultValue) {\n        return map[prop] !== undefined ? map[prop] : defaultValue;\n      };\n\n      SkeletonJson.blendModeFromString = function (str) {\n        str = str.toLowerCase();\n        if (str == \"normal\") return core.BlendMode.Normal;\n        if (str == \"additive\") return core.BlendMode.Additive;\n        if (str == \"multiply\") return core.BlendMode.Multiply;\n        if (str == \"screen\") return core.BlendMode.Screen;\n        throw new Error(\"Unknown blend mode: \" + str);\n      };\n\n      SkeletonJson.positionModeFromString = function (str) {\n        str = str.toLowerCase();\n        if (str == \"fixed\") return core.PositionMode.Fixed;\n        if (str == \"percent\") return core.PositionMode.Percent;\n        throw new Error(\"Unknown position mode: \" + str);\n      };\n\n      SkeletonJson.spacingModeFromString = function (str) {\n        str = str.toLowerCase();\n        if (str == \"length\") return core.SpacingMode.Length;\n        if (str == \"fixed\") return core.SpacingMode.Fixed;\n        if (str == \"percent\") return core.SpacingMode.Percent;\n        throw new Error(\"Unknown position mode: \" + str);\n      };\n\n      SkeletonJson.rotateModeFromString = function (str) {\n        str = str.toLowerCase();\n        if (str == \"tangent\") return core.RotateMode.Tangent;\n        if (str == \"chain\") return core.RotateMode.Chain;\n        if (str == \"chainscale\") return core.RotateMode.ChainScale;\n        throw new Error(\"Unknown rotate mode: \" + str);\n      };\n\n      SkeletonJson.transformModeFromString = function (str) {\n        str = str.toLowerCase();\n        if (str == \"normal\") return core.TransformMode.Normal;\n        if (str == \"onlytranslation\") return core.TransformMode.OnlyTranslation;\n        if (str == \"norotationorreflection\") return core.TransformMode.NoRotationOrReflection;\n        if (str == \"noscale\") return core.TransformMode.NoScale;\n        if (str == \"noscaleorreflection\") return core.TransformMode.NoScaleOrReflection;\n        throw new Error(\"Unknown transform mode: \" + str);\n      };\n\n      return SkeletonJson;\n    }();\n\n    core.SkeletonJson = SkeletonJson;\n\n    var LinkedMesh = function () {\n      function LinkedMesh(mesh, skin, slotIndex, parent) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n      }\n\n      return LinkedMesh;\n    }();\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Skin = function () {\n      function Skin(name) {\n        this.attachments = new Array();\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n      }\n\n      Skin.prototype.addAttachment = function (slotIndex, name, attachment) {\n        if (attachment == null) throw new Error(\"attachment cannot be null.\");\n        var attachments = this.attachments;\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n      };\n\n      Skin.prototype.getAttachment = function (slotIndex, name) {\n        var dictionary = this.attachments[slotIndex];\n        return dictionary ? dictionary[name] : null;\n      };\n\n      Skin.prototype.attachAll = function (skeleton, oldSkin) {\n        var slotIndex = 0;\n\n        for (var i = 0; i < skeleton.slots.length; i++) {\n          var slot = skeleton.slots[i];\n          var slotAttachment = slot.getAttachment();\n\n          if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n            var dictionary = oldSkin.attachments[slotIndex];\n\n            for (var key in dictionary) {\n              var skinAttachment = dictionary[key];\n\n              if (slotAttachment == skinAttachment) {\n                var attachment = this.getAttachment(slotIndex, key);\n                if (attachment != null) slot.setAttachment(attachment);\n                break;\n              }\n            }\n          }\n\n          slotIndex++;\n        }\n      };\n\n      return Skin;\n    }();\n\n    core.Skin = Skin;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Slot = function () {\n      function Slot(data, bone) {\n        this.attachmentVertices = new Array();\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (bone == null) throw new Error(\"bone cannot be null.\");\n        this.data = data;\n        this.bone = bone;\n        this.color = new core.Color();\n        this.darkColor = data.darkColor == null ? null : new core.Color();\n        this.setToSetupPose();\n        this.blendMode = this.data.blendMode;\n      }\n\n      Slot.prototype.getAttachment = function () {\n        return this.attachment;\n      };\n\n      Slot.prototype.setAttachment = function (attachment) {\n        if (this.attachment == attachment) return;\n        this.attachment = attachment;\n        this.attachmentTime = this.bone.skeleton.time;\n        this.attachmentVertices.length = 0;\n      };\n\n      Slot.prototype.setAttachmentTime = function (time) {\n        this.attachmentTime = this.bone.skeleton.time - time;\n      };\n\n      Slot.prototype.getAttachmentTime = function () {\n        return this.bone.skeleton.time - this.attachmentTime;\n      };\n\n      Slot.prototype.setToSetupPose = function () {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor != null) this.darkColor.setFromColor(this.data.darkColor);\n        if (this.data.attachmentName == null) this.attachment = null;else {\n          this.attachment = null;\n          this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n      };\n\n      return Slot;\n    }();\n\n    core.Slot = Slot;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SlotData = function () {\n      function SlotData(index, name, boneData) {\n        this.color = new core.Color(1, 1, 1, 1);\n        if (index < 0) throw new Error(\"index must be >= 0.\");\n        if (name == null) throw new Error(\"name cannot be null.\");\n        if (boneData == null) throw new Error(\"boneData cannot be null.\");\n        this.index = index;\n        this.name = name;\n        this.boneData = boneData;\n      }\n\n      return SlotData;\n    }();\n\n    core.SlotData = SlotData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Texture = function () {\n      function Texture(image) {\n        this._image = image;\n      }\n\n      Texture.prototype.getImage = function () {\n        return this._image;\n      };\n\n      Texture.filterFromString = function (text) {\n        switch (text.toLowerCase()) {\n          case \"nearest\":\n            return TextureFilter.Nearest;\n\n          case \"linear\":\n            return TextureFilter.Linear;\n\n          case \"mipmap\":\n            return TextureFilter.MipMap;\n\n          case \"mipmapnearestnearest\":\n            return TextureFilter.MipMapNearestNearest;\n\n          case \"mipmaplinearnearest\":\n            return TextureFilter.MipMapLinearNearest;\n\n          case \"mipmapnearestlinear\":\n            return TextureFilter.MipMapNearestLinear;\n\n          case \"mipmaplinearlinear\":\n            return TextureFilter.MipMapLinearLinear;\n\n          default:\n            throw new Error(\"Unknown texture filter \" + text);\n        }\n      };\n\n      Texture.wrapFromString = function (text) {\n        switch (text.toLowerCase()) {\n          case \"mirroredtepeat\":\n            return TextureWrap.MirroredRepeat;\n\n          case \"clamptoedge\":\n            return TextureWrap.ClampToEdge;\n\n          case \"repeat\":\n            return TextureWrap.Repeat;\n\n          default:\n            throw new Error(\"Unknown texture wrap \" + text);\n        }\n      };\n\n      return Texture;\n    }();\n\n    core.Texture = Texture;\n    var TextureFilter;\n\n    (function (TextureFilter) {\n      TextureFilter[TextureFilter[\"Nearest\"] = 9728] = \"Nearest\";\n      TextureFilter[TextureFilter[\"Linear\"] = 9729] = \"Linear\";\n      TextureFilter[TextureFilter[\"MipMap\"] = 9987] = \"MipMap\";\n      TextureFilter[TextureFilter[\"MipMapNearestNearest\"] = 9984] = \"MipMapNearestNearest\";\n      TextureFilter[TextureFilter[\"MipMapLinearNearest\"] = 9985] = \"MipMapLinearNearest\";\n      TextureFilter[TextureFilter[\"MipMapNearestLinear\"] = 9986] = \"MipMapNearestLinear\";\n      TextureFilter[TextureFilter[\"MipMapLinearLinear\"] = 9987] = \"MipMapLinearLinear\";\n    })(TextureFilter = core.TextureFilter || (core.TextureFilter = {}));\n\n    var TextureWrap;\n\n    (function (TextureWrap) {\n      TextureWrap[TextureWrap[\"MirroredRepeat\"] = 33648] = \"MirroredRepeat\";\n      TextureWrap[TextureWrap[\"ClampToEdge\"] = 33071] = \"ClampToEdge\";\n      TextureWrap[TextureWrap[\"Repeat\"] = 10497] = \"Repeat\";\n    })(TextureWrap = core.TextureWrap || (core.TextureWrap = {}));\n\n    var TextureRegion = function () {\n      function TextureRegion() {\n        this.size = null;\n      }\n\n      Object.defineProperty(TextureRegion.prototype, \"width\", {\n        get: function () {\n          var tex = this.texture;\n\n          if (PIXI.VERSION[0] == '3') {\n            return tex.crop.width;\n          }\n\n          if (tex.trim) {\n            return tex.trim.width;\n          }\n\n          return tex.orig.width;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"height\", {\n        get: function () {\n          var tex = this.texture;\n\n          if (PIXI.VERSION[0] == '3') {\n            return tex.crop.height;\n          }\n\n          if (tex.trim) {\n            return tex.trim.height;\n          }\n\n          return tex.orig.height;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"u\", {\n        get: function () {\n          return this.texture._uvs.x0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"v\", {\n        get: function () {\n          return this.texture._uvs.y0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"u2\", {\n        get: function () {\n          return this.texture._uvs.x2;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"v2\", {\n        get: function () {\n          return this.texture._uvs.y2;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"offsetX\", {\n        get: function () {\n          var tex = this.texture;\n          return tex.trim ? tex.trim.x : 0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"offsetY\", {\n        get: function () {\n          console.warn(\"Deprecation Warning: @Hackerham: I guess, if you are using PIXI-SPINE ATLAS region.offsetY, you want a texture, right? Use region.texture from now on.\");\n          return this.spineOffsetY;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"pixiOffsetY\", {\n        get: function () {\n          var tex = this.texture;\n          return tex.trim ? tex.trim.y : 0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"spineOffsetY\", {\n        get: function () {\n          var tex = this.texture;\n          return this.originalHeight - this.height - (tex.trim ? tex.trim.y : 0);\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"originalWidth\", {\n        get: function () {\n          var tex = this.texture;\n\n          if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n              return tex.trim.width;\n            }\n\n            return tex.crop.width;\n          }\n\n          return tex.orig.width;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"originalHeight\", {\n        get: function () {\n          var tex = this.texture;\n\n          if (PIXI.VERSION[0] == '3') {\n            if (tex.trim) {\n              return tex.trim.height;\n            }\n\n            return tex.crop.height;\n          }\n\n          return tex.orig.height;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"x\", {\n        get: function () {\n          return this.texture.frame.x;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"y\", {\n        get: function () {\n          return this.texture.frame.y;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      Object.defineProperty(TextureRegion.prototype, \"rotate\", {\n        get: function () {\n          return this.texture.rotate !== 0;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      return TextureRegion;\n    }();\n\n    core.TextureRegion = TextureRegion;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var TextureAtlas = function () {\n      function TextureAtlas(atlasText, textureLoader, callback) {\n        this.pages = new Array();\n        this.regions = new Array();\n\n        if (atlasText) {\n          this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n      }\n\n      TextureAtlas.prototype.addTexture = function (name, texture) {\n        var pages = this.pages;\n        var page = null;\n\n        for (var i = 0; i < pages.length; i++) {\n          if (pages[i].baseTexture === texture.baseTexture) {\n            page = pages[i];\n            break;\n          }\n        }\n\n        if (page === null) {\n          page = new TextureAtlasPage();\n          page.name = 'texturePage';\n          var baseTexture = texture.baseTexture;\n          page.width = baseTexture.realWidth;\n          page.height = baseTexture.realHeight;\n          page.baseTexture = baseTexture;\n          page.minFilter = page.magFilter = core.TextureFilter.Nearest;\n          page.uWrap = core.TextureWrap.ClampToEdge;\n          page.vWrap = core.TextureWrap.ClampToEdge;\n          pages.push(page);\n        }\n\n        var region = new TextureAtlasRegion();\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n        return region;\n      };\n\n      TextureAtlas.prototype.addTextureHash = function (textures, stripExtension) {\n        for (var key in textures) {\n          if (textures.hasOwnProperty(key)) {\n            this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n          }\n        }\n      };\n\n      TextureAtlas.prototype.addSpineAtlas = function (atlasText, textureLoader, callback) {\n        return this.load(atlasText, textureLoader, callback);\n      };\n\n      TextureAtlas.prototype.load = function (atlasText, textureLoader, callback) {\n        var _this = this;\n\n        if (textureLoader == null) throw new Error(\"textureLoader cannot be null.\");\n        var reader = new TextureAtlasReader(atlasText);\n        var tuple = new Array(4);\n        var page = null;\n\n        var iterateParser = function () {\n          while (true) {\n            var line = reader.readLine();\n\n            if (line == null) {\n              return callback && callback(_this);\n            }\n\n            line = line.trim();\n            if (line.length == 0) page = null;else if (!page) {\n              page = new TextureAtlasPage();\n              page.name = line;\n\n              if (reader.readTuple(tuple) == 2) {\n                page.width = parseInt(tuple[0]);\n                page.height = parseInt(tuple[1]);\n                reader.readTuple(tuple);\n              }\n\n              reader.readTuple(tuple);\n              page.minFilter = core.Texture.filterFromString(tuple[0]);\n              page.magFilter = core.Texture.filterFromString(tuple[1]);\n              var direction = reader.readValue();\n              page.uWrap = core.TextureWrap.ClampToEdge;\n              page.vWrap = core.TextureWrap.ClampToEdge;\n              if (direction == \"x\") page.uWrap = core.TextureWrap.Repeat;else if (direction == \"y\") page.vWrap = core.TextureWrap.Repeat;else if (direction == \"xy\") page.uWrap = page.vWrap = core.TextureWrap.Repeat;\n              textureLoader(line, function (texture) {\n                if (texture === null) {\n                  _this.pages.splice(_this.pages.indexOf(page), 1);\n\n                  return callback && callback(null);\n                }\n\n                page.baseTexture = texture;\n\n                if (!texture.valid) {\n                  texture.setSize(page.width, page.height);\n                }\n\n                _this.pages.push(page);\n\n                page.setFilters();\n\n                if (!page.width || !page.height) {\n                  page.width = texture.realWidth;\n                  page.height = texture.realHeight;\n\n                  if (!page.width || !page.height) {\n                    console.log(\"ERROR spine atlas page \" + page.name + \": meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)\");\n                  }\n                }\n\n                iterateParser();\n              });\n\n              _this.pages.push(page);\n\n              break;\n            } else {\n              var region = new TextureAtlasRegion();\n              region.name = line;\n              region.page = page;\n              var rotate = reader.readValue() == \"true\" ? 6 : 0;\n              reader.readTuple(tuple);\n              var x = parseInt(tuple[0]);\n              var y = parseInt(tuple[1]);\n              reader.readTuple(tuple);\n              var width = parseInt(tuple[0]);\n              var height = parseInt(tuple[1]);\n              var resolution = page.baseTexture.resolution;\n              x /= resolution;\n              y /= resolution;\n              width /= resolution;\n              height /= resolution;\n              var frame = new PIXI.Rectangle(x, y, rotate ? height : width, rotate ? width : height);\n\n              if (reader.readTuple(tuple) == 4) {\n                if (reader.readTuple(tuple) == 4) {\n                  reader.readTuple(tuple);\n                }\n              }\n\n              var originalWidth = parseInt(tuple[0]) / resolution;\n              var originalHeight = parseInt(tuple[1]) / resolution;\n              reader.readTuple(tuple);\n              var offsetX = parseInt(tuple[0]) / resolution;\n              var offsetY = parseInt(tuple[1]) / resolution;\n              var orig = new PIXI.Rectangle(0, 0, originalWidth, originalHeight);\n              var trim = new PIXI.Rectangle(offsetX, originalHeight - height - offsetY, width, height);\n\n              if (PIXI.VERSION[0] != '3') {\n                region.texture = new PIXI.Texture(region.page.baseTexture, frame, orig, trim, rotate);\n              } else {\n                var frame2 = new PIXI.Rectangle(x, y, width, height);\n                var crop = frame2.clone();\n                trim.width = originalWidth;\n                trim.height = originalHeight;\n                region.texture = new PIXI.Texture(region.page.baseTexture, frame2, crop, trim, rotate);\n              }\n\n              region.index = parseInt(reader.readValue());\n              region.texture.updateUvs();\n\n              _this.regions.push(region);\n            }\n          }\n        };\n\n        iterateParser();\n      };\n\n      TextureAtlas.prototype.findRegion = function (name) {\n        for (var i = 0; i < this.regions.length; i++) {\n          if (this.regions[i].name == name) {\n            return this.regions[i];\n          }\n        }\n\n        return null;\n      };\n\n      TextureAtlas.prototype.dispose = function () {\n        for (var i = 0; i < this.pages.length; i++) {\n          this.pages[i].baseTexture.dispose();\n        }\n      };\n\n      return TextureAtlas;\n    }();\n\n    core.TextureAtlas = TextureAtlas;\n\n    var TextureAtlasReader = function () {\n      function TextureAtlasReader(text) {\n        this.index = 0;\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n      }\n\n      TextureAtlasReader.prototype.readLine = function () {\n        if (this.index >= this.lines.length) return null;\n        return this.lines[this.index++];\n      };\n\n      TextureAtlasReader.prototype.readValue = function () {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw new Error(\"Invalid line: \" + line);\n        return line.substring(colon + 1).trim();\n      };\n\n      TextureAtlasReader.prototype.readTuple = function (tuple) {\n        var line = this.readLine();\n        var colon = line.indexOf(\":\");\n        if (colon == -1) throw new Error(\"Invalid line: \" + line);\n        var i = 0,\n            lastMatch = colon + 1;\n\n        for (; i < 3; i++) {\n          var comma = line.indexOf(\",\", lastMatch);\n          if (comma == -1) break;\n          tuple[i] = line.substr(lastMatch, comma - lastMatch).trim();\n          lastMatch = comma + 1;\n        }\n\n        tuple[i] = line.substring(lastMatch).trim();\n        return i + 1;\n      };\n\n      return TextureAtlasReader;\n    }();\n\n    var TextureAtlasPage = function () {\n      function TextureAtlasPage() {}\n\n      TextureAtlasPage.prototype.setFilters = function () {\n        var tex = this.baseTexture;\n        var filter = this.minFilter;\n\n        if (filter == core.TextureFilter.Linear) {\n          tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n        } else if (this.minFilter == core.TextureFilter.Nearest) {\n          tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n        } else {\n          tex.mipmap = PIXI.MIPMAP_MODES.POW2;\n\n          if (filter == core.TextureFilter.MipMapNearestNearest) {\n            tex.scaleMode = PIXI.SCALE_MODES.NEAREST;\n          } else {\n            tex.scaleMode = PIXI.SCALE_MODES.LINEAR;\n          }\n        }\n      };\n\n      return TextureAtlasPage;\n    }();\n\n    core.TextureAtlasPage = TextureAtlasPage;\n\n    var TextureAtlasRegion = function (_super) {\n      __extends(TextureAtlasRegion, _super);\n\n      function TextureAtlasRegion() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      return TextureAtlasRegion;\n    }(core.TextureRegion);\n\n    core.TextureAtlasRegion = TextureAtlasRegion;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var TransformConstraint = function () {\n      function TransformConstraint(data, skeleton) {\n        this.rotateMix = 0;\n        this.translateMix = 0;\n        this.scaleMix = 0;\n        this.shearMix = 0;\n        this.temp = new core.Vector2();\n        if (data == null) throw new Error(\"data cannot be null.\");\n        if (skeleton == null) throw new Error(\"skeleton cannot be null.\");\n        this.data = data;\n        this.rotateMix = data.rotateMix;\n        this.translateMix = data.translateMix;\n        this.scaleMix = data.scaleMix;\n        this.shearMix = data.shearMix;\n        this.bones = new Array();\n\n        for (var i = 0; i < data.bones.length; i++) this.bones.push(skeleton.findBone(data.bones[i].name));\n\n        this.target = skeleton.findBone(data.target.name);\n      }\n\n      TransformConstraint.prototype.apply = function () {\n        this.update();\n      };\n\n      TransformConstraint.prototype.update = function () {\n        if (this.data.local) {\n          if (this.data.relative) this.applyRelativeLocal();else this.applyAbsoluteLocal();\n        } else {\n          if (this.data.relative) this.applyRelativeWorld();else this.applyAbsoluteWorld();\n        }\n      };\n\n      TransformConstraint.prototype.applyAbsoluteWorld = function () {\n        var rotateMix = this.rotateMix,\n            translateMix = this.translateMix,\n            scaleMix = this.scaleMix,\n            shearMix = this.shearMix;\n        var target = this.target;\n        var targetMat = target.matrix;\n        var ta = targetMat.a,\n            tb = targetMat.c,\n            tc = targetMat.b,\n            td = targetMat.d;\n        var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n        var offsetRotation = this.data.offsetRotation * degRadReflect;\n        var offsetShearY = this.data.offsetShearY * degRadReflect;\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          var modified = false;\n          var mat = bone.matrix;\n\n          if (rotateMix != 0) {\n            var a = mat.a,\n                b = mat.c,\n                c = mat.b,\n                d = mat.d;\n            var r = Math.atan2(tc, ta) - Math.atan2(c, a) + offsetRotation;\n            if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n            r *= rotateMix;\n            var cos = Math.cos(r),\n                sin = Math.sin(r);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n            modified = true;\n          }\n\n          if (translateMix != 0) {\n            var temp = this.temp;\n            target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n            mat.tx += (temp.x - mat.tx) * translateMix;\n            mat.ty += (temp.y - mat.ty) * translateMix;\n            modified = true;\n          }\n\n          if (scaleMix > 0) {\n            var s = Math.sqrt(mat.a * mat.a + mat.b * mat.b);\n            var ts = Math.sqrt(ta * ta + tc * tc);\n            if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleX) * scaleMix) / s;\n            mat.a *= s;\n            mat.b *= s;\n            s = Math.sqrt(mat.c * mat.c + mat.d * mat.d);\n            ts = Math.sqrt(tb * tb + td * td);\n            if (s > 0.00001) s = (s + (ts - s + this.data.offsetScaleY) * scaleMix) / s;\n            mat.c *= s;\n            mat.d *= s;\n            modified = true;\n          }\n\n          if (shearMix > 0) {\n            var b = mat.c,\n                d = mat.d;\n            var by = Math.atan2(d, b);\n            var r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(mat.b, mat.a));\n            if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n            r = by + (r + offsetShearY) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            mat.c = Math.cos(r) * s;\n            mat.d = Math.sin(r) * s;\n            modified = true;\n          }\n\n          if (modified) bone.appliedValid = false;\n        }\n      };\n\n      TransformConstraint.prototype.applyRelativeWorld = function () {\n        var rotateMix = this.rotateMix,\n            translateMix = this.translateMix,\n            scaleMix = this.scaleMix,\n            shearMix = this.shearMix;\n        var target = this.target;\n        var targetMat = target.matrix;\n        var ta = targetMat.a,\n            tb = targetMat.c,\n            tc = targetMat.b,\n            td = targetMat.d;\n        var degRadReflect = ta * td - tb * tc > 0 ? core.MathUtils.degRad : -core.MathUtils.degRad;\n        var offsetRotation = this.data.offsetRotation * degRadReflect,\n            offsetShearY = this.data.offsetShearY * degRadReflect;\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          var modified = false;\n          var mat = bone.matrix;\n\n          if (rotateMix != 0) {\n            var a = mat.a,\n                b = mat.c,\n                c = mat.b,\n                d = mat.d;\n            var r = Math.atan2(tc, ta) + offsetRotation;\n            if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n            r *= rotateMix;\n            var cos = Math.cos(r),\n                sin = Math.sin(r);\n            mat.a = cos * a - sin * c;\n            mat.c = cos * b - sin * d;\n            mat.b = sin * a + cos * c;\n            mat.d = sin * b + cos * d;\n            modified = true;\n          }\n\n          if (translateMix != 0) {\n            var temp = this.temp;\n            target.localToWorld(temp.set(this.data.offsetX, this.data.offsetY));\n            mat.tx += temp.x * translateMix;\n            mat.ty += temp.y * translateMix;\n            modified = true;\n          }\n\n          if (scaleMix > 0) {\n            var s = (Math.sqrt(ta * ta + tc * tc) - 1 + this.data.offsetScaleX) * scaleMix + 1;\n            mat.a *= s;\n            mat.b *= s;\n            s = (Math.sqrt(tb * tb + td * td) - 1 + this.data.offsetScaleY) * scaleMix + 1;\n            mat.c *= s;\n            mat.d *= s;\n            modified = true;\n          }\n\n          if (shearMix > 0) {\n            var r = Math.atan2(td, tb) - Math.atan2(tc, ta);\n            if (r > core.MathUtils.PI) r -= core.MathUtils.PI2;else if (r < -core.MathUtils.PI) r += core.MathUtils.PI2;\n            var b = mat.c,\n                d = mat.d;\n            r = Math.atan2(d, b) + (r - core.MathUtils.PI / 2 + offsetShearY) * shearMix;\n            var s = Math.sqrt(b * b + d * d);\n            mat.c = Math.cos(r) * s;\n            mat.d = Math.sin(r) * s;\n            modified = true;\n          }\n\n          if (modified) bone.appliedValid = false;\n        }\n      };\n\n      TransformConstraint.prototype.applyAbsoluteLocal = function () {\n        var rotateMix = this.rotateMix,\n            translateMix = this.translateMix,\n            scaleMix = this.scaleMix,\n            shearMix = this.shearMix;\n        var target = this.target;\n        if (!target.appliedValid) target.updateAppliedTransform();\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          if (!bone.appliedValid) bone.updateAppliedTransform();\n          var rotation = bone.arotation;\n\n          if (rotateMix != 0) {\n            var r = target.arotation - rotation + this.data.offsetRotation;\n            r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n            rotation += r * rotateMix;\n          }\n\n          var x = bone.ax,\n              y = bone.ay;\n\n          if (translateMix != 0) {\n            x += (target.ax - x + this.data.offsetX) * translateMix;\n            y += (target.ay - y + this.data.offsetY) * translateMix;\n          }\n\n          var scaleX = bone.ascaleX,\n              scaleY = bone.ascaleY;\n\n          if (scaleMix > 0) {\n            if (scaleX > 0.00001) scaleX = (scaleX + (target.ascaleX - scaleX + this.data.offsetScaleX) * scaleMix) / scaleX;\n            if (scaleY > 0.00001) scaleY = (scaleY + (target.ascaleY - scaleY + this.data.offsetScaleY) * scaleMix) / scaleY;\n          }\n\n          var shearY = bone.ashearY;\n\n          if (shearMix > 0) {\n            var r = target.ashearY - shearY + this.data.offsetShearY;\n            r -= (16384 - (16384.499999999996 - r / 360 | 0)) * 360;\n            bone.shearY += r * shearMix;\n          }\n\n          bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n      };\n\n      TransformConstraint.prototype.applyRelativeLocal = function () {\n        var rotateMix = this.rotateMix,\n            translateMix = this.translateMix,\n            scaleMix = this.scaleMix,\n            shearMix = this.shearMix;\n        var target = this.target;\n        if (!target.appliedValid) target.updateAppliedTransform();\n        var bones = this.bones;\n\n        for (var i = 0, n = bones.length; i < n; i++) {\n          var bone = bones[i];\n          if (!bone.appliedValid) bone.updateAppliedTransform();\n          var rotation = bone.arotation;\n          if (rotateMix != 0) rotation += (target.arotation + this.data.offsetRotation) * rotateMix;\n          var x = bone.ax,\n              y = bone.ay;\n\n          if (translateMix != 0) {\n            x += (target.ax + this.data.offsetX) * translateMix;\n            y += (target.ay + this.data.offsetY) * translateMix;\n          }\n\n          var scaleX = bone.ascaleX,\n              scaleY = bone.ascaleY;\n\n          if (scaleMix > 0) {\n            if (scaleX > 0.00001) scaleX *= (target.ascaleX - 1 + this.data.offsetScaleX) * scaleMix + 1;\n            if (scaleY > 0.00001) scaleY *= (target.ascaleY - 1 + this.data.offsetScaleY) * scaleMix + 1;\n          }\n\n          var shearY = bone.ashearY;\n          if (shearMix > 0) shearY += (target.ashearY + this.data.offsetShearY) * shearMix;\n          bone.updateWorldTransformWith(x, y, rotation, scaleX, scaleY, bone.ashearX, shearY);\n        }\n      };\n\n      TransformConstraint.prototype.getOrder = function () {\n        return this.data.order;\n      };\n\n      return TransformConstraint;\n    }();\n\n    core.TransformConstraint = TransformConstraint;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var TransformConstraintData = function () {\n      function TransformConstraintData(name) {\n        this.order = 0;\n        this.bones = new Array();\n        this.rotateMix = 0;\n        this.translateMix = 0;\n        this.scaleMix = 0;\n        this.shearMix = 0;\n        this.offsetRotation = 0;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.offsetScaleX = 0;\n        this.offsetScaleY = 0;\n        this.offsetShearY = 0;\n        this.relative = false;\n        this.local = false;\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n      }\n\n      return TransformConstraintData;\n    }();\n\n    core.TransformConstraintData = TransformConstraintData;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Triangulator = function () {\n      function Triangulator() {\n        this.convexPolygons = new Array();\n        this.convexPolygonsIndices = new Array();\n        this.indicesArray = new Array();\n        this.isConcaveArray = new Array();\n        this.triangles = new Array();\n        this.polygonPool = new core.Pool(function () {\n          return new Array();\n        });\n        this.polygonIndicesPool = new core.Pool(function () {\n          return new Array();\n        });\n      }\n\n      Triangulator.prototype.triangulate = function (verticesArray) {\n        var vertices = verticesArray;\n        var vertexCount = verticesArray.length >> 1;\n        var indices = this.indicesArray;\n        indices.length = 0;\n\n        for (var i = 0; i < vertexCount; i++) indices[i] = i;\n\n        var isConcave = this.isConcaveArray;\n        isConcave.length = 0;\n\n        for (var i = 0, n = vertexCount; i < n; ++i) isConcave[i] = Triangulator.isConcave(i, vertexCount, vertices, indices);\n\n        var triangles = this.triangles;\n        triangles.length = 0;\n\n        while (vertexCount > 3) {\n          var previous = vertexCount - 1,\n              i = 0,\n              next = 1;\n\n          while (true) {\n            outer: if (!isConcave[i]) {\n              var p1 = indices[previous] << 1,\n                  p2 = indices[i] << 1,\n                  p3 = indices[next] << 1;\n              var p1x = vertices[p1],\n                  p1y = vertices[p1 + 1];\n              var p2x = vertices[p2],\n                  p2y = vertices[p2 + 1];\n              var p3x = vertices[p3],\n                  p3y = vertices[p3 + 1];\n\n              for (var ii = (next + 1) % vertexCount; ii != previous; ii = (ii + 1) % vertexCount) {\n                if (!isConcave[ii]) continue;\n                var v = indices[ii] << 1;\n                var vx = vertices[v],\n                    vy = vertices[v + 1];\n\n                if (Triangulator.positiveArea(p3x, p3y, p1x, p1y, vx, vy)) {\n                  if (Triangulator.positiveArea(p1x, p1y, p2x, p2y, vx, vy)) {\n                    if (Triangulator.positiveArea(p2x, p2y, p3x, p3y, vx, vy)) break outer;\n                  }\n                }\n              }\n\n              break;\n            }\n\n            if (next == 0) {\n              do {\n                if (!isConcave[i]) break;\n                i--;\n              } while (i > 0);\n\n              break;\n            }\n\n            previous = i;\n            i = next;\n            next = (next + 1) % vertexCount;\n          }\n\n          triangles.push(indices[(vertexCount + i - 1) % vertexCount]);\n          triangles.push(indices[i]);\n          triangles.push(indices[(i + 1) % vertexCount]);\n          indices.splice(i, 1);\n          isConcave.splice(i, 1);\n          vertexCount--;\n          var previousIndex = (vertexCount + i - 1) % vertexCount;\n          var nextIndex = i == vertexCount ? 0 : i;\n          isConcave[previousIndex] = Triangulator.isConcave(previousIndex, vertexCount, vertices, indices);\n          isConcave[nextIndex] = Triangulator.isConcave(nextIndex, vertexCount, vertices, indices);\n        }\n\n        if (vertexCount == 3) {\n          triangles.push(indices[2]);\n          triangles.push(indices[0]);\n          triangles.push(indices[1]);\n        }\n\n        return triangles;\n      };\n\n      Triangulator.prototype.decompose = function (verticesArray, triangles) {\n        var vertices = verticesArray;\n        var convexPolygons = this.convexPolygons;\n        this.polygonPool.freeAll(convexPolygons);\n        convexPolygons.length = 0;\n        var convexPolygonsIndices = this.convexPolygonsIndices;\n        this.polygonIndicesPool.freeAll(convexPolygonsIndices);\n        convexPolygonsIndices.length = 0;\n        var polygonIndices = this.polygonIndicesPool.obtain();\n        polygonIndices.length = 0;\n        var polygon = this.polygonPool.obtain();\n        polygon.length = 0;\n        var fanBaseIndex = -1,\n            lastWinding = 0;\n\n        for (var i = 0, n = triangles.length; i < n; i += 3) {\n          var t1 = triangles[i] << 1,\n              t2 = triangles[i + 1] << 1,\n              t3 = triangles[i + 2] << 1;\n          var x1 = vertices[t1],\n              y1 = vertices[t1 + 1];\n          var x2 = vertices[t2],\n              y2 = vertices[t2 + 1];\n          var x3 = vertices[t3],\n              y3 = vertices[t3 + 1];\n          var merged = false;\n\n          if (fanBaseIndex == t1) {\n            var o = polygon.length - 4;\n            var winding1 = Triangulator.winding(polygon[o], polygon[o + 1], polygon[o + 2], polygon[o + 3], x3, y3);\n            var winding2 = Triangulator.winding(x3, y3, polygon[0], polygon[1], polygon[2], polygon[3]);\n\n            if (winding1 == lastWinding && winding2 == lastWinding) {\n              polygon.push(x3);\n              polygon.push(y3);\n              polygonIndices.push(t3);\n              merged = true;\n            }\n          }\n\n          if (!merged) {\n            if (polygon.length > 0) {\n              convexPolygons.push(polygon);\n              convexPolygonsIndices.push(polygonIndices);\n            } else {\n              this.polygonPool.free(polygon);\n              this.polygonIndicesPool.free(polygonIndices);\n            }\n\n            polygon = this.polygonPool.obtain();\n            polygon.length = 0;\n            polygon.push(x1);\n            polygon.push(y1);\n            polygon.push(x2);\n            polygon.push(y2);\n            polygon.push(x3);\n            polygon.push(y3);\n            polygonIndices = this.polygonIndicesPool.obtain();\n            polygonIndices.length = 0;\n            polygonIndices.push(t1);\n            polygonIndices.push(t2);\n            polygonIndices.push(t3);\n            lastWinding = Triangulator.winding(x1, y1, x2, y2, x3, y3);\n            fanBaseIndex = t1;\n          }\n        }\n\n        if (polygon.length > 0) {\n          convexPolygons.push(polygon);\n          convexPolygonsIndices.push(polygonIndices);\n        }\n\n        for (var i = 0, n = convexPolygons.length; i < n; i++) {\n          polygonIndices = convexPolygonsIndices[i];\n          if (polygonIndices.length == 0) continue;\n          var firstIndex = polygonIndices[0];\n          var lastIndex = polygonIndices[polygonIndices.length - 1];\n          polygon = convexPolygons[i];\n          var o = polygon.length - 4;\n          var prevPrevX = polygon[o],\n              prevPrevY = polygon[o + 1];\n          var prevX = polygon[o + 2],\n              prevY = polygon[o + 3];\n          var firstX = polygon[0],\n              firstY = polygon[1];\n          var secondX = polygon[2],\n              secondY = polygon[3];\n          var winding = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, firstX, firstY);\n\n          for (var ii = 0; ii < n; ii++) {\n            if (ii == i) continue;\n            var otherIndices = convexPolygonsIndices[ii];\n            if (otherIndices.length != 3) continue;\n            var otherFirstIndex = otherIndices[0];\n            var otherSecondIndex = otherIndices[1];\n            var otherLastIndex = otherIndices[2];\n            var otherPoly = convexPolygons[ii];\n            var x3 = otherPoly[otherPoly.length - 2],\n                y3 = otherPoly[otherPoly.length - 1];\n            if (otherFirstIndex != firstIndex || otherSecondIndex != lastIndex) continue;\n            var winding1 = Triangulator.winding(prevPrevX, prevPrevY, prevX, prevY, x3, y3);\n            var winding2 = Triangulator.winding(x3, y3, firstX, firstY, secondX, secondY);\n\n            if (winding1 == winding && winding2 == winding) {\n              otherPoly.length = 0;\n              otherIndices.length = 0;\n              polygon.push(x3);\n              polygon.push(y3);\n              polygonIndices.push(otherLastIndex);\n              prevPrevX = prevX;\n              prevPrevY = prevY;\n              prevX = x3;\n              prevY = y3;\n              ii = 0;\n            }\n          }\n        }\n\n        for (var i = convexPolygons.length - 1; i >= 0; i--) {\n          polygon = convexPolygons[i];\n\n          if (polygon.length == 0) {\n            convexPolygons.splice(i, 1);\n            this.polygonPool.free(polygon);\n            polygonIndices = convexPolygonsIndices[i];\n            convexPolygonsIndices.splice(i, 1);\n            this.polygonIndicesPool.free(polygonIndices);\n          }\n        }\n\n        return convexPolygons;\n      };\n\n      Triangulator.isConcave = function (index, vertexCount, vertices, indices) {\n        var previous = indices[(vertexCount + index - 1) % vertexCount] << 1;\n        var current = indices[index] << 1;\n        var next = indices[(index + 1) % vertexCount] << 1;\n        return !this.positiveArea(vertices[previous], vertices[previous + 1], vertices[current], vertices[current + 1], vertices[next], vertices[next + 1]);\n      };\n\n      Triangulator.positiveArea = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n        return p1x * (p3y - p2y) + p2x * (p1y - p3y) + p3x * (p2y - p1y) >= 0;\n      };\n\n      Triangulator.winding = function (p1x, p1y, p2x, p2y, p3x, p3y) {\n        var px = p2x - p1x,\n            py = p2y - p1y;\n        return p3x * py - p3y * px + px * p1y - p1x * py >= 0 ? 1 : -1;\n      };\n\n      return Triangulator;\n    }();\n\n    core.Triangulator = Triangulator;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var IntSet = function () {\n      function IntSet() {\n        this.array = new Array();\n      }\n\n      IntSet.prototype.add = function (value) {\n        var contains = this.contains(value);\n        this.array[value | 0] = value | 0;\n        return !contains;\n      };\n\n      IntSet.prototype.contains = function (value) {\n        return this.array[value | 0] != undefined;\n      };\n\n      IntSet.prototype.remove = function (value) {\n        this.array[value | 0] = undefined;\n      };\n\n      IntSet.prototype.clear = function () {\n        this.array.length = 0;\n      };\n\n      return IntSet;\n    }();\n\n    core.IntSet = IntSet;\n\n    var Color = function () {\n      function Color(r, g, b, a) {\n        if (r === void 0) {\n          r = 0;\n        }\n\n        if (g === void 0) {\n          g = 0;\n        }\n\n        if (b === void 0) {\n          b = 0;\n        }\n\n        if (a === void 0) {\n          a = 0;\n        }\n\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n      }\n\n      Color.prototype.set = function (r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        this.clamp();\n        return this;\n      };\n\n      Color.prototype.setFromColor = function (c) {\n        this.r = c.r;\n        this.g = c.g;\n        this.b = c.b;\n        this.a = c.a;\n        return this;\n      };\n\n      Color.prototype.setFromString = function (hex) {\n        hex = hex.charAt(0) == '#' ? hex.substr(1) : hex;\n        this.r = parseInt(hex.substr(0, 2), 16) / 255.0;\n        this.g = parseInt(hex.substr(2, 2), 16) / 255.0;\n        this.b = parseInt(hex.substr(4, 2), 16) / 255.0;\n        this.a = (hex.length != 8 ? 255 : parseInt(hex.substr(6, 2), 16)) / 255.0;\n        return this;\n      };\n\n      Color.prototype.add = function (r, g, b, a) {\n        this.r += r;\n        this.g += g;\n        this.b += b;\n        this.a += a;\n        this.clamp();\n        return this;\n      };\n\n      Color.prototype.clamp = function () {\n        if (this.r < 0) this.r = 0;else if (this.r > 1) this.r = 1;\n        if (this.g < 0) this.g = 0;else if (this.g > 1) this.g = 1;\n        if (this.b < 0) this.b = 0;else if (this.b > 1) this.b = 1;\n        if (this.a < 0) this.a = 0;else if (this.a > 1) this.a = 1;\n        return this;\n      };\n\n      Color.WHITE = new Color(1, 1, 1, 1);\n      Color.RED = new Color(1, 0, 0, 1);\n      Color.GREEN = new Color(0, 1, 0, 1);\n      Color.BLUE = new Color(0, 0, 1, 1);\n      Color.MAGENTA = new Color(1, 0, 1, 1);\n      return Color;\n    }();\n\n    core.Color = Color;\n\n    var MathUtils = function () {\n      function MathUtils() {}\n\n      MathUtils.clamp = function (value, min, max) {\n        if (value < min) return min;\n        if (value > max) return max;\n        return value;\n      };\n\n      MathUtils.cosDeg = function (degrees) {\n        return Math.cos(degrees * MathUtils.degRad);\n      };\n\n      MathUtils.sinDeg = function (degrees) {\n        return Math.sin(degrees * MathUtils.degRad);\n      };\n\n      MathUtils.signum = function (value) {\n        return value > 0 ? 1 : value < 0 ? -1 : 0;\n      };\n\n      MathUtils.toInt = function (x) {\n        return x > 0 ? Math.floor(x) : Math.ceil(x);\n      };\n\n      MathUtils.cbrt = function (x) {\n        var y = Math.pow(Math.abs(x), 1 / 3);\n        return x < 0 ? -y : y;\n      };\n\n      MathUtils.randomTriangular = function (min, max) {\n        return MathUtils.randomTriangularWith(min, max, (min + max) * 0.5);\n      };\n\n      MathUtils.randomTriangularWith = function (min, max, mode) {\n        var u = Math.random();\n        var d = max - min;\n        if (u <= (mode - min) / d) return min + Math.sqrt(u * d * (mode - min));\n        return max - Math.sqrt((1 - u) * d * (max - mode));\n      };\n\n      MathUtils.PI = 3.1415927;\n      MathUtils.PI2 = MathUtils.PI * 2;\n      MathUtils.radiansToDegrees = 180 / MathUtils.PI;\n      MathUtils.radDeg = MathUtils.radiansToDegrees;\n      MathUtils.degreesToRadians = MathUtils.PI / 180;\n      MathUtils.degRad = MathUtils.degreesToRadians;\n      return MathUtils;\n    }();\n\n    core.MathUtils = MathUtils;\n\n    var Interpolation = function () {\n      function Interpolation() {}\n\n      Interpolation.prototype.apply = function (start, end, a) {\n        return start + (end - start) * this.applyInternal(a);\n      };\n\n      return Interpolation;\n    }();\n\n    core.Interpolation = Interpolation;\n\n    var Pow = function (_super) {\n      __extends(Pow, _super);\n\n      function Pow(power) {\n        var _this = _super.call(this) || this;\n\n        _this.power = 2;\n        _this.power = power;\n        return _this;\n      }\n\n      Pow.prototype.applyInternal = function (a) {\n        if (a <= 0.5) return Math.pow(a * 2, this.power) / 2;\n        return Math.pow((a - 1) * 2, this.power) / (this.power % 2 == 0 ? -2 : 2) + 1;\n      };\n\n      return Pow;\n    }(Interpolation);\n\n    core.Pow = Pow;\n\n    var PowOut = function (_super) {\n      __extends(PowOut, _super);\n\n      function PowOut(power) {\n        return _super.call(this, power) || this;\n      }\n\n      PowOut.prototype.applyInternal = function (a) {\n        return Math.pow(a - 1, this.power) * (this.power % 2 == 0 ? -1 : 1) + 1;\n      };\n\n      return PowOut;\n    }(Pow);\n\n    core.PowOut = PowOut;\n\n    var Utils = function () {\n      function Utils() {}\n\n      Utils.arrayCopy = function (source, sourceStart, dest, destStart, numElements) {\n        for (var i = sourceStart, j = destStart; i < sourceStart + numElements; i++, j++) {\n          dest[j] = source[i];\n        }\n      };\n\n      Utils.setArraySize = function (array, size, value) {\n        if (value === void 0) {\n          value = 0;\n        }\n\n        var oldSize = array.length;\n        if (oldSize == size) return array;\n        array.length = size;\n\n        if (oldSize < size) {\n          for (var i = oldSize; i < size; i++) array[i] = value;\n        }\n\n        return array;\n      };\n\n      Utils.ensureArrayCapacity = function (array, size, value) {\n        if (value === void 0) {\n          value = 0;\n        }\n\n        if (array.length >= size) return array;\n        return Utils.setArraySize(array, size, value);\n      };\n\n      Utils.newArray = function (size, defaultValue) {\n        var array = new Array(size);\n\n        for (var i = 0; i < size; i++) array[i] = defaultValue;\n\n        return array;\n      };\n\n      Utils.newFloatArray = function (size) {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n          return new Float32Array(size);\n        } else {\n          var array = new Array(size);\n\n          for (var i = 0; i < array.length; i++) array[i] = 0;\n\n          return array;\n        }\n      };\n\n      Utils.newShortArray = function (size) {\n        if (Utils.SUPPORTS_TYPED_ARRAYS) {\n          return new Int16Array(size);\n        } else {\n          var array = new Array(size);\n\n          for (var i = 0; i < array.length; i++) array[i] = 0;\n\n          return array;\n        }\n      };\n\n      Utils.toFloatArray = function (array) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? new Float32Array(array) : array;\n      };\n\n      Utils.toSinglePrecision = function (value) {\n        return Utils.SUPPORTS_TYPED_ARRAYS ? Math.fround(value) : value;\n      };\n\n      Utils.webkit602BugfixHelper = function (alpha, blend) {};\n\n      Utils.SUPPORTS_TYPED_ARRAYS = typeof Float32Array !== \"undefined\";\n      return Utils;\n    }();\n\n    core.Utils = Utils;\n\n    var DebugUtils = function () {\n      function DebugUtils() {}\n\n      DebugUtils.logBones = function (skeleton) {\n        for (var i = 0; i < skeleton.bones.length; i++) {\n          var bone = skeleton.bones[i];\n          var mat = bone.matrix;\n          console.log(bone.data.name + \", \" + mat.a + \", \" + mat.b + \", \" + mat.c + \", \" + mat.d + \", \" + mat.tx + \", \" + mat.ty);\n        }\n      };\n\n      return DebugUtils;\n    }();\n\n    core.DebugUtils = DebugUtils;\n\n    var Pool = function () {\n      function Pool(instantiator) {\n        this.items = new Array();\n        this.instantiator = instantiator;\n      }\n\n      Pool.prototype.obtain = function () {\n        return this.items.length > 0 ? this.items.pop() : this.instantiator();\n      };\n\n      Pool.prototype.free = function (item) {\n        if (item.reset) item.reset();\n        this.items.push(item);\n      };\n\n      Pool.prototype.freeAll = function (items) {\n        for (var i = 0; i < items.length; i++) {\n          if (items[i].reset) items[i].reset();\n          this.items[i] = items[i];\n        }\n      };\n\n      Pool.prototype.clear = function () {\n        this.items.length = 0;\n      };\n\n      return Pool;\n    }();\n\n    core.Pool = Pool;\n\n    var Vector2 = function () {\n      function Vector2(x, y) {\n        if (x === void 0) {\n          x = 0;\n        }\n\n        if (y === void 0) {\n          y = 0;\n        }\n\n        this.x = x;\n        this.y = y;\n      }\n\n      Vector2.prototype.set = function (x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n      };\n\n      Vector2.prototype.length = function () {\n        var x = this.x;\n        var y = this.y;\n        return Math.sqrt(x * x + y * y);\n      };\n\n      Vector2.prototype.normalize = function () {\n        var len = this.length();\n\n        if (len != 0) {\n          this.x /= len;\n          this.y /= len;\n        }\n\n        return this;\n      };\n\n      return Vector2;\n    }();\n\n    core.Vector2 = Vector2;\n\n    var TimeKeeper = function () {\n      function TimeKeeper() {\n        this.maxDelta = 0.064;\n        this.framesPerSecond = 0;\n        this.delta = 0;\n        this.totalTime = 0;\n        this.lastTime = Date.now() / 1000;\n        this.frameCount = 0;\n        this.frameTime = 0;\n      }\n\n      TimeKeeper.prototype.update = function () {\n        var now = Date.now() / 1000;\n        this.delta = now - this.lastTime;\n        this.frameTime += this.delta;\n        this.totalTime += this.delta;\n        if (this.delta > this.maxDelta) this.delta = this.maxDelta;\n        this.lastTime = now;\n        this.frameCount++;\n\n        if (this.frameTime > 1) {\n          this.framesPerSecond = this.frameCount / this.frameTime;\n          this.frameTime = 0;\n          this.frameCount = 0;\n        }\n      };\n\n      return TimeKeeper;\n    }();\n\n    core.TimeKeeper = TimeKeeper;\n\n    var WindowedMean = function () {\n      function WindowedMean(windowSize) {\n        if (windowSize === void 0) {\n          windowSize = 32;\n        }\n\n        this.addedValues = 0;\n        this.lastValue = 0;\n        this.mean = 0;\n        this.dirty = true;\n        this.values = new Array(windowSize);\n      }\n\n      WindowedMean.prototype.hasEnoughData = function () {\n        return this.addedValues >= this.values.length;\n      };\n\n      WindowedMean.prototype.addValue = function (value) {\n        if (this.addedValues < this.values.length) this.addedValues++;\n        this.values[this.lastValue++] = value;\n        if (this.lastValue > this.values.length - 1) this.lastValue = 0;\n        this.dirty = true;\n      };\n\n      WindowedMean.prototype.getMean = function () {\n        if (this.hasEnoughData()) {\n          if (this.dirty) {\n            var mean = 0;\n\n            for (var i = 0; i < this.values.length; i++) {\n              mean += this.values[i];\n            }\n\n            this.mean = mean / this.values.length;\n            this.dirty = false;\n          }\n\n          return this.mean;\n        } else {\n          return 0;\n        }\n      };\n\n      return WindowedMean;\n    }();\n\n    core.WindowedMean = WindowedMean;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var Attachment = function () {\n      function Attachment(name) {\n        if (name == null) throw new Error(\"name cannot be null.\");\n        this.name = name;\n      }\n\n      return Attachment;\n    }();\n\n    core.Attachment = Attachment;\n\n    var VertexAttachment = function (_super) {\n      __extends(VertexAttachment, _super);\n\n      function VertexAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.id = (VertexAttachment.nextID++ & 65535) << 11;\n        _this.worldVerticesLength = 0;\n        return _this;\n      }\n\n      VertexAttachment.prototype.computeWorldVerticesOld = function (slot, worldVertices) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n      };\n\n      VertexAttachment.prototype.computeWorldVertices = function (slot, start, count, worldVertices, offset, stride) {\n        count = offset + (count >> 1) * stride;\n        var skeleton = slot.bone.skeleton;\n        var deformArray = slot.attachmentVertices;\n        var vertices = this.vertices;\n        var bones = this.bones;\n\n        if (bones == null) {\n          if (deformArray.length > 0) vertices = deformArray;\n          var mat = slot.bone.matrix;\n          var x = mat.tx;\n          var y = mat.ty;\n          var a = mat.a,\n              b = mat.c,\n              c = mat.b,\n              d = mat.d;\n\n          for (var v_1 = start, w = offset; w < count; v_1 += 2, w += stride) {\n            var vx = vertices[v_1],\n                vy = vertices[v_1 + 1];\n            worldVertices[w] = vx * a + vy * b + x;\n            worldVertices[w + 1] = vx * c + vy * d + y;\n          }\n\n          return;\n        }\n\n        var v = 0,\n            skip = 0;\n\n        for (var i = 0; i < start; i += 2) {\n          var n = bones[v];\n          v += n + 1;\n          skip += n;\n        }\n\n        var skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n          for (var w = offset, b = skip * 3; w < count; w += stride) {\n            var wx = 0,\n                wy = 0;\n            var n = bones[v++];\n            n += v;\n\n            for (; v < n; v++, b += 3) {\n              var mat = skeletonBones[bones[v]].matrix;\n              var vx = vertices[b],\n                  vy = vertices[b + 1],\n                  weight = vertices[b + 2];\n              wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n              wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n            }\n\n            worldVertices[w] = wx;\n            worldVertices[w + 1] = wy;\n          }\n        } else {\n          var deform = deformArray;\n\n          for (var w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n            var wx = 0,\n                wy = 0;\n            var n = bones[v++];\n            n += v;\n\n            for (; v < n; v++, b += 3, f += 2) {\n              var mat = skeletonBones[bones[v]].matrix;\n              var vx = vertices[b] + deform[f],\n                  vy = vertices[b + 1] + deform[f + 1],\n                  weight = vertices[b + 2];\n              wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n              wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n            }\n\n            worldVertices[w] = wx;\n            worldVertices[w + 1] = wy;\n          }\n        }\n      };\n\n      VertexAttachment.prototype.applyDeform = function (sourceAttachment) {\n        return this == sourceAttachment;\n      };\n\n      VertexAttachment.nextID = 0;\n      return VertexAttachment;\n    }(Attachment);\n\n    core.VertexAttachment = VertexAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var AttachmentType;\n\n    (function (AttachmentType) {\n      AttachmentType[AttachmentType[\"Region\"] = 0] = \"Region\";\n      AttachmentType[AttachmentType[\"BoundingBox\"] = 1] = \"BoundingBox\";\n      AttachmentType[AttachmentType[\"Mesh\"] = 2] = \"Mesh\";\n      AttachmentType[AttachmentType[\"LinkedMesh\"] = 3] = \"LinkedMesh\";\n      AttachmentType[AttachmentType[\"Path\"] = 4] = \"Path\";\n      AttachmentType[AttachmentType[\"Point\"] = 5] = \"Point\";\n    })(AttachmentType = core.AttachmentType || (core.AttachmentType = {}));\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var BoundingBoxAttachment = function (_super) {\n      __extends(BoundingBoxAttachment, _super);\n\n      function BoundingBoxAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.color = new core.Color(1, 1, 1, 1);\n        return _this;\n      }\n\n      return BoundingBoxAttachment;\n    }(core.VertexAttachment);\n\n    core.BoundingBoxAttachment = BoundingBoxAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var ClippingAttachment = function (_super) {\n      __extends(ClippingAttachment, _super);\n\n      function ClippingAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.color = new core.Color(0.2275, 0.2275, 0.8078, 1);\n        return _this;\n      }\n\n      return ClippingAttachment;\n    }(core.VertexAttachment);\n\n    core.ClippingAttachment = ClippingAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var MeshAttachment = function (_super) {\n      __extends(MeshAttachment, _super);\n\n      function MeshAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.color = new core.Color(1, 1, 1, 1);\n        _this.inheritDeform = false;\n        _this.tempColor = new core.Color(0, 0, 0, 0);\n        return _this;\n      }\n\n      MeshAttachment.prototype.applyDeform = function (sourceAttachment) {\n        return this == sourceAttachment || this.inheritDeform && this.parentMesh == sourceAttachment;\n      };\n\n      MeshAttachment.prototype.getParentMesh = function () {\n        return this.parentMesh;\n      };\n\n      MeshAttachment.prototype.setParentMesh = function (parentMesh) {\n        this.parentMesh = parentMesh;\n\n        if (parentMesh != null) {\n          this.bones = parentMesh.bones;\n          this.vertices = parentMesh.vertices;\n          this.worldVerticesLength = parentMesh.worldVerticesLength;\n          this.regionUVs = parentMesh.regionUVs;\n          this.triangles = parentMesh.triangles;\n          this.hullLength = parentMesh.hullLength;\n          this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n      };\n\n      return MeshAttachment;\n    }(core.VertexAttachment);\n\n    core.MeshAttachment = MeshAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var PathAttachment = function (_super) {\n      __extends(PathAttachment, _super);\n\n      function PathAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.closed = false;\n        _this.constantSpeed = false;\n        _this.color = new core.Color(1, 1, 1, 1);\n        return _this;\n      }\n\n      return PathAttachment;\n    }(core.VertexAttachment);\n\n    core.PathAttachment = PathAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var PointAttachment = function (_super) {\n      __extends(PointAttachment, _super);\n\n      function PointAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.color = new core.Color(0.38, 0.94, 0, 1);\n        return _this;\n      }\n\n      PointAttachment.prototype.computeWorldPosition = function (bone, point) {\n        var mat = bone.matrix;\n        point.x = this.x * mat.a + this.y * mat.c + bone.worldX;\n        point.y = this.x * mat.b + this.y * mat.d + bone.worldY;\n        return point;\n      };\n\n      PointAttachment.prototype.computeWorldRotation = function (bone) {\n        var mat = bone.matrix;\n        var cos = core.MathUtils.cosDeg(this.rotation),\n            sin = core.MathUtils.sinDeg(this.rotation);\n        var x = cos * mat.a + sin * mat.c;\n        var y = cos * mat.b + sin * mat.d;\n        return Math.atan2(y, x) * core.MathUtils.radDeg;\n      };\n\n      return PointAttachment;\n    }(core.VertexAttachment);\n\n    core.PointAttachment = PointAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var RegionAttachment = function (_super) {\n      __extends(RegionAttachment, _super);\n\n      function RegionAttachment(name) {\n        var _this = _super.call(this, name) || this;\n\n        _this.x = 0;\n        _this.y = 0;\n        _this.scaleX = 1;\n        _this.scaleY = 1;\n        _this.rotation = 0;\n        _this.width = 0;\n        _this.height = 0;\n        _this.color = new core.Color(1, 1, 1, 1);\n        _this.offset = core.Utils.newFloatArray(8);\n        _this.uvs = core.Utils.newFloatArray(8);\n        _this.tempColor = new core.Color(1, 1, 1, 1);\n        return _this;\n      }\n\n      RegionAttachment.prototype.updateOffset = function () {\n        var regionScaleX = this.width / this.region.originalWidth * this.scaleX;\n        var regionScaleY = this.height / this.region.originalHeight * this.scaleY;\n        var localX = -this.width / 2 * this.scaleX + this.region.offsetX * regionScaleX;\n        var localY = -this.height / 2 * this.scaleY + this.region.offsetY * regionScaleY;\n        var localX2 = localX + this.region.width * regionScaleX;\n        var localY2 = localY + this.region.height * regionScaleY;\n        var radians = this.rotation * Math.PI / 180;\n        var cos = Math.cos(radians);\n        var sin = Math.sin(radians);\n        var localXCos = localX * cos + this.x;\n        var localXSin = localX * sin;\n        var localYCos = localY * cos + this.y;\n        var localYSin = localY * sin;\n        var localX2Cos = localX2 * cos + this.x;\n        var localX2Sin = localX2 * sin;\n        var localY2Cos = localY2 * cos + this.y;\n        var localY2Sin = localY2 * sin;\n        var offset = this.offset;\n        offset[RegionAttachment.OX1] = localXCos - localYSin;\n        offset[RegionAttachment.OY1] = localYCos + localXSin;\n        offset[RegionAttachment.OX2] = localXCos - localY2Sin;\n        offset[RegionAttachment.OY2] = localY2Cos + localXSin;\n        offset[RegionAttachment.OX3] = localX2Cos - localY2Sin;\n        offset[RegionAttachment.OY3] = localY2Cos + localX2Sin;\n        offset[RegionAttachment.OX4] = localX2Cos - localYSin;\n        offset[RegionAttachment.OY4] = localYCos + localX2Sin;\n      };\n\n      RegionAttachment.prototype.setRegion = function (region) {\n        this.region = region;\n        var uvs = this.uvs;\n\n        if (region.rotate) {\n          uvs[2] = region.u;\n          uvs[3] = region.v2;\n          uvs[4] = region.u;\n          uvs[5] = region.v;\n          uvs[6] = region.u2;\n          uvs[7] = region.v;\n          uvs[0] = region.u2;\n          uvs[1] = region.v2;\n        } else {\n          uvs[0] = region.u;\n          uvs[1] = region.v2;\n          uvs[2] = region.u;\n          uvs[3] = region.v;\n          uvs[4] = region.u2;\n          uvs[5] = region.v;\n          uvs[6] = region.u2;\n          uvs[7] = region.v2;\n        }\n      };\n\n      RegionAttachment.prototype.computeWorldVertices = function (bone, worldVertices, offset, stride) {\n        var vertexOffset = this.offset;\n        var mat = bone.matrix;\n        var x = mat.tx,\n            y = mat.ty;\n        var a = mat.a,\n            b = mat.c,\n            c = mat.b,\n            d = mat.d;\n        var offsetX = 0,\n            offsetY = 0;\n        offsetX = vertexOffset[RegionAttachment.OX1];\n        offsetY = vertexOffset[RegionAttachment.OY1];\n        worldVertices[offset] = offsetX * a + offsetY * b + x;\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n        offsetX = vertexOffset[RegionAttachment.OX2];\n        offsetY = vertexOffset[RegionAttachment.OY2];\n        worldVertices[offset] = offsetX * a + offsetY * b + x;\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n        offsetX = vertexOffset[RegionAttachment.OX3];\n        offsetY = vertexOffset[RegionAttachment.OY3];\n        worldVertices[offset] = offsetX * a + offsetY * b + x;\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n        offset += stride;\n        offsetX = vertexOffset[RegionAttachment.OX4];\n        offsetY = vertexOffset[RegionAttachment.OY4];\n        worldVertices[offset] = offsetX * a + offsetY * b + x;\n        worldVertices[offset + 1] = offsetX * c + offsetY * d + y;\n      };\n\n      RegionAttachment.OX1 = 0;\n      RegionAttachment.OY1 = 1;\n      RegionAttachment.OX2 = 2;\n      RegionAttachment.OY2 = 3;\n      RegionAttachment.OX3 = 4;\n      RegionAttachment.OY3 = 5;\n      RegionAttachment.OX4 = 6;\n      RegionAttachment.OY4 = 7;\n      RegionAttachment.X1 = 0;\n      RegionAttachment.Y1 = 1;\n      RegionAttachment.C1R = 2;\n      RegionAttachment.C1G = 3;\n      RegionAttachment.C1B = 4;\n      RegionAttachment.C1A = 5;\n      RegionAttachment.U1 = 6;\n      RegionAttachment.V1 = 7;\n      RegionAttachment.X2 = 8;\n      RegionAttachment.Y2 = 9;\n      RegionAttachment.C2R = 10;\n      RegionAttachment.C2G = 11;\n      RegionAttachment.C2B = 12;\n      RegionAttachment.C2A = 13;\n      RegionAttachment.U2 = 14;\n      RegionAttachment.V2 = 15;\n      RegionAttachment.X3 = 16;\n      RegionAttachment.Y3 = 17;\n      RegionAttachment.C3R = 18;\n      RegionAttachment.C3G = 19;\n      RegionAttachment.C3B = 20;\n      RegionAttachment.C3A = 21;\n      RegionAttachment.U3 = 22;\n      RegionAttachment.V3 = 23;\n      RegionAttachment.X4 = 24;\n      RegionAttachment.Y4 = 25;\n      RegionAttachment.C4R = 26;\n      RegionAttachment.C4G = 27;\n      RegionAttachment.C4B = 28;\n      RegionAttachment.C4A = 29;\n      RegionAttachment.U4 = 30;\n      RegionAttachment.V4 = 31;\n      return RegionAttachment;\n    }(core.Attachment);\n\n    core.RegionAttachment = RegionAttachment;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var JitterEffect = function () {\n      function JitterEffect(jitterX, jitterY) {\n        this.jitterX = 0;\n        this.jitterY = 0;\n        this.jitterX = jitterX;\n        this.jitterY = jitterY;\n      }\n\n      JitterEffect.prototype.begin = function (skeleton) {};\n\n      JitterEffect.prototype.transform = function (position, uv, light, dark) {\n        position.x += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n        position.y += core.MathUtils.randomTriangular(-this.jitterX, this.jitterY);\n      };\n\n      JitterEffect.prototype.end = function () {};\n\n      return JitterEffect;\n    }();\n\n    core.JitterEffect = JitterEffect;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  var core;\n\n  (function (core) {\n    var SwirlEffect = function () {\n      function SwirlEffect(radius) {\n        this.centerX = 0;\n        this.centerY = 0;\n        this.radius = 0;\n        this.angle = 0;\n        this.worldX = 0;\n        this.worldY = 0;\n        this.radius = radius;\n      }\n\n      SwirlEffect.prototype.begin = function (skeleton) {\n        this.worldX = skeleton.x + this.centerX;\n        this.worldY = skeleton.y + this.centerY;\n      };\n\n      SwirlEffect.prototype.transform = function (position, uv, light, dark) {\n        var radAngle = this.angle * core.MathUtils.degreesToRadians;\n        var x = position.x - this.worldX;\n        var y = position.y - this.worldY;\n        var dist = Math.sqrt(x * x + y * y);\n\n        if (dist < this.radius) {\n          var theta = SwirlEffect.interpolation.apply(0, radAngle, (this.radius - dist) / this.radius);\n          var cos = Math.cos(theta);\n          var sin = Math.sin(theta);\n          position.x = cos * x - sin * y + this.worldX;\n          position.y = sin * x + cos * y + this.worldY;\n        }\n      };\n\n      SwirlEffect.prototype.end = function () {};\n\n      SwirlEffect.interpolation = new core.PowOut(2);\n      return SwirlEffect;\n    }();\n\n    core.SwirlEffect = SwirlEffect;\n  })(core = pixi_spine.core || (pixi_spine.core = {}));\n})(pixi_spine || (pixi_spine = {}));\n\n(function () {\n  if (!Math.fround) {\n    Math.fround = Math.fround = function (array) {\n      return function (x) {\n        return array[0] = x, array[0];\n      };\n    }(new Float32Array(1));\n  }\n})();\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  pixi_spine.core.Bone.yDown = true;\n  var tempRgb = [0, 0, 0];\n\n  var SpineSprite = function (_super) {\n    __extends(SpineSprite, _super);\n\n    function SpineSprite() {\n      var _this = _super !== null && _super.apply(this, arguments) || this;\n\n      _this.region = null;\n      return _this;\n    }\n\n    return SpineSprite;\n  }(PIXI.Sprite);\n\n  pixi_spine.SpineSprite = SpineSprite;\n\n  var SpineMesh = function (_super) {\n    __extends(SpineMesh, _super);\n\n    function SpineMesh(texture, vertices, uvs, indices, drawMode) {\n      return _super.call(this, texture, vertices, uvs, indices, drawMode) || this;\n    }\n\n    return SpineMesh;\n  }(PIXI.SimpleMesh);\n\n  pixi_spine.SpineMesh = SpineMesh;\n\n  var Spine = function (_super) {\n    __extends(Spine, _super);\n\n    function Spine(spineData) {\n      var _this = _super.call(this) || this;\n\n      if (!spineData) {\n        throw new Error('The spineData param is required.');\n      }\n\n      if (typeof spineData === \"string\") {\n        throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n      }\n\n      _this.spineData = spineData;\n      _this.skeleton = new pixi_spine.core.Skeleton(spineData);\n\n      _this.skeleton.updateWorldTransform();\n\n      _this.stateData = new pixi_spine.core.AnimationStateData(spineData);\n      _this.state = new pixi_spine.core.AnimationState(_this.stateData);\n      _this.slotContainers = [];\n      _this.tempClipContainers = [];\n\n      for (var i = 0, n = _this.skeleton.slots.length; i < n; i++) {\n        var slot = _this.skeleton.slots[i];\n        var attachment = slot.attachment;\n\n        var slotContainer = _this.newContainer();\n\n        _this.slotContainers.push(slotContainer);\n\n        _this.addChild(slotContainer);\n\n        _this.tempClipContainers.push(null);\n\n        if (attachment instanceof pixi_spine.core.RegionAttachment) {\n          var spriteName = attachment.region.name;\n\n          var sprite = _this.createSprite(slot, attachment, spriteName);\n\n          slot.currentSprite = sprite;\n          slot.currentSpriteName = spriteName;\n          slotContainer.addChild(sprite);\n        } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n          var mesh = _this.createMesh(slot, attachment);\n\n          slot.currentMesh = mesh;\n          slot.currentMeshName = attachment.name;\n          slotContainer.addChild(mesh);\n        } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n          _this.createGraphics(slot, attachment);\n\n          slotContainer.addChild(slot.clippingContainer);\n          slotContainer.addChild(slot.currentGraphics);\n        } else {\n          continue;\n        }\n      }\n\n      _this.autoUpdate = true;\n      _this.tintRgb = new Float32Array([1, 1, 1]);\n      return _this;\n    }\n\n    Object.defineProperty(Spine.prototype, \"autoUpdate\", {\n      get: function () {\n        return this.updateTransform === Spine.prototype.autoUpdateTransform;\n      },\n      set: function (value) {\n        this.updateTransform = value ? Spine.prototype.autoUpdateTransform : PIXI.Container.prototype.updateTransform;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Spine.prototype, \"tint\", {\n      get: function () {\n        return PIXI.utils.rgb2hex(this.tintRgb);\n      },\n      set: function (value) {\n        this.tintRgb = PIXI.utils.hex2rgb(value, this.tintRgb);\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(Spine.prototype, \"delayLimit\", {\n      get: function () {\n        var limit = typeof this.localDelayLimit !== \"undefined\" ? this.localDelayLimit : Spine.globalDelayLimit;\n        return limit || Number.MAX_VALUE;\n      },\n      enumerable: true,\n      configurable: true\n    });\n\n    Spine.prototype.update = function (dt) {\n      var delayLimit = this.delayLimit;\n      if (dt > delayLimit) dt = delayLimit;\n      this.state.update(dt);\n      this.state.apply(this.skeleton);\n      if (!this.skeleton) return;\n      this.skeleton.updateWorldTransform();\n      var slots = this.skeleton.slots;\n      var globalClr = this.color;\n      var light = null,\n          dark = null;\n\n      if (globalClr) {\n        light = globalClr.light;\n        dark = globalClr.dark;\n      } else {\n        light = this.tintRgb;\n      }\n\n      var thack = false;\n\n      for (var i = 0, n = slots.length; i < n; i++) {\n        var slot = slots[i];\n        var attachment = slot.attachment;\n        var slotContainer = this.slotContainers[i];\n\n        if (!attachment) {\n          slotContainer.visible = false;\n          continue;\n        }\n\n        var spriteColor = null;\n        var attColor = attachment.color;\n\n        if (attachment instanceof pixi_spine.core.RegionAttachment) {\n          var region = attachment.region;\n\n          if (region) {\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n              slot.currentMesh = null;\n              slot.currentMeshName = undefined;\n            }\n\n            var ar = region;\n\n            if (!slot.currentSpriteName || slot.currentSpriteName !== ar.name) {\n              var spriteName = ar.name;\n\n              if (slot.currentSprite) {\n                slot.currentSprite.visible = false;\n              }\n\n              slot.sprites = slot.sprites || {};\n\n              if (slot.sprites[spriteName] !== undefined) {\n                slot.sprites[spriteName].visible = true;\n              } else {\n                var sprite = this.createSprite(slot, attachment, spriteName);\n                slotContainer.addChild(sprite);\n              }\n\n              slot.currentSprite = slot.sprites[spriteName];\n              slot.currentSpriteName = spriteName;\n            }\n          }\n\n          var transform = slotContainer.transform;\n          transform.setFromMatrix(slot.bone.matrix);\n\n          if (slot.currentSprite.color) {\n            spriteColor = slot.currentSprite.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentSprite.tint = PIXI.utils.rgb2hex(tempRgb);\n          }\n\n          slot.currentSprite.blendMode = slot.blendMode;\n        } else if (attachment instanceof pixi_spine.core.MeshAttachment) {\n          if (slot.currentSprite) {\n            slot.currentSprite.visible = false;\n            slot.currentSprite = null;\n            slot.currentSpriteName = undefined;\n            var transform = new PIXI.Transform();\n            transform._parentID = -1;\n            transform._worldID = slotContainer.transform._worldID;\n            slotContainer.transform = transform;\n          }\n\n          if (!slot.currentMeshName || slot.currentMeshName !== attachment.name) {\n            var meshName = attachment.name;\n\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n            }\n\n            slot.meshes = slot.meshes || {};\n\n            if (slot.meshes[meshName] !== undefined) {\n              slot.meshes[meshName].visible = true;\n            } else {\n              var mesh = this.createMesh(slot, attachment);\n              slotContainer.addChild(mesh);\n            }\n\n            slot.currentMesh = slot.meshes[meshName];\n            slot.currentMeshName = meshName;\n          }\n\n          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n\n          if (slot.currentMesh.color) {\n            spriteColor = slot.currentMesh.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentMesh.tint = PIXI.utils.rgb2hex(tempRgb);\n          }\n\n          slot.currentMesh.blendMode = slot.blendMode;\n        } else if (attachment instanceof pixi_spine.core.ClippingAttachment) {\n          if (!slot.currentGraphics) {\n            this.createGraphics(slot, attachment);\n            slotContainer.addChild(slot.clippingContainer);\n            slotContainer.addChild(slot.currentGraphics);\n          }\n\n          this.updateGraphics(slot, attachment);\n        } else {\n          slotContainer.visible = false;\n          continue;\n        }\n\n        slotContainer.visible = true;\n\n        if (spriteColor) {\n          var r0 = slot.color.r * attColor.r;\n          var g0 = slot.color.g * attColor.g;\n          var b0 = slot.color.b * attColor.b;\n          spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\n\n          if (slot.darkColor) {\n            r0 = slot.darkColor.r;\n            g0 = slot.darkColor.g;\n            b0 = slot.darkColor.b;\n          } else {\n            r0 = 0.0;\n            g0 = 0.0;\n            b0 = 0.0;\n          }\n\n          spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n        }\n\n        slotContainer.alpha = slot.color.a;\n      }\n\n      var drawOrder = this.skeleton.drawOrder;\n      var clippingAttachment = null;\n      var clippingContainer = null;\n\n      for (var i = 0, n = drawOrder.length; i < n; i++) {\n        var slot = slots[drawOrder[i].data.index];\n        var slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n        if (!clippingContainer) {\n          if (slotContainer.parent !== null && slotContainer.parent !== this) {\n            slotContainer.parent.removeChild(slotContainer);\n            slotContainer.parent = this;\n          }\n        }\n\n        if (slot.currentGraphics && slot.attachment) {\n          clippingContainer = slot.clippingContainer;\n          clippingAttachment = slot.attachment;\n          clippingContainer.children.length = 0;\n          this.children[i] = slotContainer;\n\n          if (clippingAttachment.endSlot == slot.data) {\n            clippingAttachment.endSlot = null;\n          }\n        } else {\n          if (clippingContainer) {\n            var c = this.tempClipContainers[i];\n\n            if (!c) {\n              c = this.tempClipContainers[i] = this.newContainer();\n              c.visible = false;\n            }\n\n            this.children[i] = c;\n            slotContainer.parent = null;\n            clippingContainer.addChild(slotContainer);\n\n            if (clippingAttachment.endSlot == slot.data) {\n              clippingContainer.renderable = true;\n              clippingContainer = null;\n              clippingAttachment = null;\n            }\n          } else {\n            this.children[i] = slotContainer;\n          }\n        }\n      }\n    };\n\n    ;\n\n    Spine.prototype.setSpriteRegion = function (attachment, sprite, region) {\n      sprite.region = region;\n      sprite.texture = region.texture;\n\n      if (!region.size) {\n        sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n        sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n      } else {\n        sprite.scale.x = region.size.width / region.originalWidth;\n        sprite.scale.y = -region.size.height / region.originalHeight;\n      }\n    };\n\n    Spine.prototype.setMeshRegion = function (attachment, mesh, region) {\n      mesh.region = region;\n      mesh.texture = region.texture;\n      region.texture.updateUvs();\n      mesh.uvBuffer.update(attachment.regionUVs);\n    };\n\n    Spine.prototype.autoUpdateTransform = function () {\n      if (Spine.globalAutoUpdate) {\n        this.lastTime = this.lastTime || Date.now();\n        var timeDelta = (Date.now() - this.lastTime) * 0.001;\n        this.lastTime = Date.now();\n        this.update(timeDelta);\n      } else {\n        this.lastTime = 0;\n      }\n\n      PIXI.Container.prototype.updateTransform.call(this);\n    };\n\n    ;\n\n    Spine.prototype.createSprite = function (slot, attachment, defName) {\n      var region = attachment.region;\n\n      if (slot.tempAttachment === attachment) {\n        region = slot.tempRegion;\n        slot.tempAttachment = null;\n        slot.tempRegion = null;\n      }\n\n      var texture = region.texture;\n      var sprite = this.newSprite(texture);\n      sprite.rotation = attachment.rotation * pixi_spine.core.MathUtils.degRad;\n      sprite.anchor.x = 0.5;\n      sprite.anchor.y = 0.5;\n      sprite.position.x = attachment.x;\n      sprite.position.y = attachment.y;\n      sprite.alpha = attachment.color.a;\n      sprite.region = attachment.region;\n      this.setSpriteRegion(attachment, sprite, attachment.region);\n      slot.sprites = slot.sprites || {};\n      slot.sprites[defName] = sprite;\n      return sprite;\n    };\n\n    ;\n\n    Spine.prototype.createMesh = function (slot, attachment) {\n      var region = attachment.region;\n\n      if (slot.tempAttachment === attachment) {\n        region = slot.tempRegion;\n        slot.tempAttachment = null;\n        slot.tempRegion = null;\n      }\n\n      var strip = this.newMesh(region.texture, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), PIXI.DRAW_MODES.TRIANGLES);\n\n      if (strip.canvasPadding) {\n        strip.canvasPadding = 1.5;\n      }\n\n      strip.alpha = attachment.color.a;\n      strip.region = attachment.region;\n      this.setMeshRegion(attachment, strip, region);\n      slot.meshes = slot.meshes || {};\n      slot.meshes[attachment.name] = strip;\n      return strip;\n    };\n\n    ;\n\n    Spine.prototype.createGraphics = function (slot, clip) {\n      var graphics = this.newGraphics();\n      var poly = new PIXI.Polygon([]);\n      graphics.clear();\n      graphics.beginFill(0xffffff, 1);\n      graphics.drawPolygon(poly);\n      graphics.renderable = false;\n      slot.currentGraphics = graphics;\n      slot.clippingContainer = this.newContainer();\n      slot.clippingContainer.mask = slot.currentGraphics;\n      return graphics;\n    };\n\n    Spine.prototype.updateGraphics = function (slot, clip) {\n      var geom = slot.currentGraphics.geometry;\n      var vertices = geom.graphicsData[0].shape.points;\n      var n = clip.worldVerticesLength;\n      vertices.length = n;\n      clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n      geom.dirty++;\n      geom.clearDirty++;\n    };\n\n    Spine.prototype.hackTextureBySlotIndex = function (slotIndex, texture, size) {\n      if (texture === void 0) {\n        texture = null;\n      }\n\n      if (size === void 0) {\n        size = null;\n      }\n\n      var slot = this.skeleton.slots[slotIndex];\n\n      if (!slot) {\n        return false;\n      }\n\n      var attachment = slot.attachment;\n      var region = attachment.region;\n\n      if (texture) {\n        region = new pixi_spine.core.TextureRegion();\n        region.texture = texture;\n        region.size = size;\n      }\n\n      if (slot.currentSprite && slot.currentSprite.region != region) {\n        this.setSpriteRegion(attachment, slot.currentSprite, region);\n        slot.currentSprite.region = region;\n      } else if (slot.currentMesh && slot.currentMesh.region != region) {\n        this.setMeshRegion(attachment, slot.currentMesh, region);\n      } else {\n        slot.tempRegion = region;\n        slot.tempAttachment = attachment;\n      }\n\n      return true;\n    };\n\n    Spine.prototype.hackTextureBySlotName = function (slotName, texture, size) {\n      if (texture === void 0) {\n        texture = null;\n      }\n\n      if (size === void 0) {\n        size = null;\n      }\n\n      var index = this.skeleton.findSlotIndex(slotName);\n\n      if (index == -1) {\n        return false;\n      }\n\n      return this.hackTextureBySlotIndex(index, texture, size);\n    };\n\n    Spine.prototype.newContainer = function () {\n      return new PIXI.Container();\n    };\n\n    Spine.prototype.newSprite = function (tex) {\n      return new SpineSprite(tex);\n    };\n\n    Spine.prototype.newGraphics = function () {\n      return new PIXI.Graphics();\n    };\n\n    Spine.prototype.newMesh = function (texture, vertices, uvs, indices, drawMode) {\n      return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n    };\n\n    Spine.prototype.transformHack = function () {\n      return 1;\n    };\n\n    Spine.prototype.hackAttachmentGroups = function (nameSuffix, group, outGroup) {\n      if (!nameSuffix) {\n        return;\n      }\n\n      var list_d = [],\n          list_n = [];\n\n      for (var i = 0, len = this.skeleton.slots.length; i < len; i++) {\n        var slot = this.skeleton.slots[i];\n        var name_2 = slot.currentSpriteName || slot.currentMeshName || \"\";\n        var target = slot.currentSprite || slot.currentMesh;\n\n        if (name_2.endsWith(nameSuffix)) {\n          target.parentGroup = group;\n          list_n.push(target);\n        } else if (outGroup && target) {\n          target.parentGroup = outGroup;\n          list_d.push(target);\n        }\n      }\n\n      return [list_d, list_n];\n    };\n\n    ;\n\n    Spine.prototype.destroy = function (options) {\n      for (var i = 0, n = this.skeleton.slots.length; i < n; i++) {\n        var slot = this.skeleton.slots[i];\n\n        for (var name_3 in slot.meshes) {\n          slot.meshes[name_3].destroy(options);\n        }\n\n        slot.meshes = null;\n\n        for (var name_4 in slot.sprites) {\n          slot.sprites[name_4].destroy(options);\n        }\n\n        slot.sprites = null;\n      }\n\n      for (var i = 0, n = this.slotContainers.length; i < n; i++) {\n        this.slotContainers[i].destroy(options);\n      }\n\n      this.spineData = null;\n      this.skeleton = null;\n      this.slotContainers = null;\n      this.stateData = null;\n      this.state = null;\n      this.tempClipContainers = null;\n\n      _super.prototype.destroy.call(this, options);\n    };\n\n    Spine.globalAutoUpdate = true;\n    Spine.globalDelayLimit = 0;\n    Spine.clippingPolygon = [];\n    return Spine;\n  }(PIXI.Container);\n\n  pixi_spine.Spine = Spine;\n\n  function SlotContainerUpdateTransformV3() {\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._currentBounds = null;\n  }\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  PIXI.spine = pixi_spine;\n  var TextureProto = PIXI.Texture.prototype;\n\n  if (!TextureProto._updateUvs) {\n    TextureProto._updateUvs = TextureProto.updateUvs;\n  }\n})(pixi_spine || (pixi_spine = {}));\n\nvar pixi_spine;\n\n(function (pixi_spine) {\n  function isJson(resource) {\n    return resource.type === PIXI.LoaderResource.TYPE.JSON;\n  }\n\n  var AtlasParser = function () {\n    function AtlasParser() {}\n\n    AtlasParser.use = function (resource, next) {\n      if (!resource.data || !isJson(resource) || !resource.data.bones) {\n        return next();\n      }\n\n      var metadata = resource.metadata || {};\n      var metadataSkeletonScale = metadata ? resource.metadata.spineSkeletonScale : null;\n      var metadataAtlas = metadata ? resource.metadata.spineAtlas : null;\n\n      if (metadataAtlas === false) {\n        return next();\n      }\n\n      if (metadataAtlas && metadataAtlas.pages) {\n        var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(metadataAtlas));\n\n        if (metadataSkeletonScale) {\n          spineJsonParser.scale = metadataSkeletonScale;\n        }\n\n        var skeletonData = spineJsonParser.readSkeletonData(resource.data);\n        resource.spineData = skeletonData;\n        resource.spineAtlas = metadataAtlas;\n        return next();\n      }\n\n      var metadataAtlasSuffix = metadata.spineAtlasSuffix || '.atlas';\n      var atlasPath = resource.url;\n      var queryStringPos = atlasPath.indexOf('?');\n\n      if (queryStringPos > 0) {\n        atlasPath = atlasPath.substr(0, queryStringPos);\n      }\n\n      atlasPath = atlasPath.substr(0, atlasPath.lastIndexOf('.')) + metadataAtlasSuffix;\n\n      if (resource.metadata && resource.metadata.spineAtlasFile) {\n        atlasPath = resource.metadata.spineAtlasFile;\n      }\n\n      atlasPath = atlasPath.replace(this.baseUrl, '');\n      var atlasOptions = {\n        crossOrigin: resource.crossOrigin,\n        xhrType: PIXI.LoaderResource.XHR_RESPONSE_TYPE.TEXT,\n        metadata: metadata.spineMetadata || null,\n        parentResource: resource\n      };\n      var imageOptions = {\n        crossOrigin: resource.crossOrigin,\n        metadata: metadata.imageMetadata || null,\n        parentResource: resource\n      };\n      var baseUrl = resource.url.substr(0, resource.url.lastIndexOf('/') + 1);\n      baseUrl = baseUrl.replace(this.baseUrl, '');\n      var namePrefix = metadata.imageNamePrefix || resource.name + '_atlas_page_';\n      var adapter = metadata.images ? staticImageLoader(metadata.images) : metadata.image ? staticImageLoader({\n        'default': metadata.image\n      }) : metadata.imageLoader ? metadata.imageLoader(this, namePrefix, baseUrl, imageOptions) : imageLoaderAdapter(this, namePrefix, baseUrl, imageOptions);\n\n      var createSkeletonWithRawAtlas = function (rawData) {\n        new pixi_spine.core.TextureAtlas(rawData, adapter, function (spineAtlas) {\n          if (spineAtlas) {\n            var spineJsonParser = new pixi_spine.core.SkeletonJson(new pixi_spine.core.AtlasAttachmentLoader(spineAtlas));\n\n            if (metadataSkeletonScale) {\n              spineJsonParser.scale = metadataSkeletonScale;\n            }\n\n            resource.spineData = spineJsonParser.readSkeletonData(resource.data);\n            resource.spineAtlas = spineAtlas;\n          }\n\n          next();\n        });\n      };\n\n      if (resource.metadata && resource.metadata.atlasRawData) {\n        createSkeletonWithRawAtlas(resource.metadata.atlasRawData);\n      } else {\n        this.add(resource.name + '_atlas', atlasPath, atlasOptions, function (atlasResource) {\n          if (!atlasResource.error) {\n            createSkeletonWithRawAtlas(atlasResource.data);\n          } else {\n            next();\n          }\n        });\n      }\n    };\n\n    return AtlasParser;\n  }();\n\n  pixi_spine.AtlasParser = AtlasParser;\n\n  function imageLoaderAdapter(loader, namePrefix, baseUrl, imageOptions) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n      baseUrl += '/';\n    }\n\n    return function (line, callback) {\n      var name = namePrefix + line;\n      var url = baseUrl + line;\n      var cachedResource = loader.resources[name];\n\n      if (cachedResource) {\n        function done() {\n          callback(cachedResource.texture.baseTexture);\n        }\n\n        if (cachedResource.texture) {\n          done();\n        } else {\n          cachedResource.onAfterMiddleware.add(done);\n        }\n      } else {\n        loader.add(name, url, imageOptions, function (resource) {\n          if (!resource.error) {\n            callback(resource.texture.baseTexture);\n          } else {\n            callback(null);\n          }\n        });\n      }\n    };\n  }\n\n  pixi_spine.imageLoaderAdapter = imageLoaderAdapter;\n\n  function syncImageLoaderAdapter(baseUrl, crossOrigin) {\n    if (baseUrl && baseUrl.lastIndexOf('/') !== baseUrl.length - 1) {\n      baseUrl += '/';\n    }\n\n    return function (line, callback) {\n      callback(PIXI.BaseTexture.from(line, crossOrigin));\n    };\n  }\n\n  pixi_spine.syncImageLoaderAdapter = syncImageLoaderAdapter;\n\n  function staticImageLoader(pages) {\n    return function (line, callback) {\n      var page = pages[line] || pages['default'];\n      if (page && page.baseTexture) callback(page.baseTexture);else callback(page);\n    };\n  }\n\n  pixi_spine.staticImageLoader = staticImageLoader;\n\n  if (PIXI.Loader) {\n    PIXI.Loader.registerPlugin(AtlasParser);\n  }\n})(pixi_spine || (pixi_spine = {}));\n\n//# sourceURL=webpack:///./node_modules/pixi-spine/bin/pixi-spine.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var pixi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pixi.js */ \"./node_modules/pixi.js/lib/pixi.es.js\");\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pixi-spine */ \"./node_modules/pixi-spine/bin/pixi-spine.js\");\n/* harmony import */ var pixi_spine__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pixi_spine__WEBPACK_IMPORTED_MODULE_1__);\n// import { helloWorld } from './helloWorld';\n//\n// document.write(helloWorld());\n// const PIXI = require(\"pixi-spine\");\n\n //\n\nvar app = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"Application\"](); //\n\ndocument.body.appendChild(app.view); //\n\napp.loader.add('spineCharacter', 'assets/skineboy-pro.json').load(function (loader, resources) {\n  var animation = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"spine\"].Spine(resources.spineCharacter.spineData); // add the animation to the scene and render...\n\n  app.stage.addChild(animation); // run\n\n  var animation = new pixi_js__WEBPACK_IMPORTED_MODULE_0__[\"spine\"].Spine(spineBoyData);\n\n  if (animation.state.hasAnimation('run')) {\n    // run forever, little boy!\n    animation.state.setAnimation(0, 'run', true); // dont run too fast\n\n    animation.state.timeScale = 0.1;\n  }\n\n  app.start();\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

})